<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cpprefjp - C++日本語リファレンス</title>
  <link href="https://cpprefjp.github.io" />
  <updated>2025-07-09T15:44:39.511650</updated>
  <id>b7f6f51d-d395-4098-9b8a-c6bd2e38de43</id>

  
    <entry>
      <title>atan2 -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/atan2.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/atan2.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/atan2.md b/reference/valarray/valarray/atan2.md
index 683238d9f..566cd6e6d 100644
--- a/reference/valarray/valarray/atan2.md
+++ b/reference/valarray/valarray/atan2.md
@@ -74,7 +74,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `ys` と `xs` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&amp; -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_and.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_and.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_and.md b/reference/valarray/valarray/op_and.md
index c357bbdd4..de4e148c7 100644
--- a/reference/valarray/valarray/op_and.md
+++ b/reference/valarray/valarray/op_and.md
@@ -69,7 +69,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator/ -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_divide.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_divide.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_divide.md b/reference/valarray/valarray/op_divide.md
index 67d31a227..9d7452838 100644
--- a/reference/valarray/valarray/op_divide.md
+++ b/reference/valarray/valarray/op_divide.md
@@ -70,7 +70,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator== -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_equal.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_equal.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_equal.md b/reference/valarray/valarray/op_equal.md
index 03b19ee42..ec6a56e52 100644
--- a/reference/valarray/valarray/op_equal.md
+++ b/reference/valarray/valarray/op_equal.md
@@ -75,7 +75,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&gt; -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_greater.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_greater.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_greater.md b/reference/valarray/valarray/op_greater.md
index 9c3162847..bb6e5595b 100644
--- a/reference/valarray/valarray/op_greater.md
+++ b/reference/valarray/valarray/op_greater.md
@@ -75,7 +75,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&gt;= -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_greater_equal.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_greater_equal.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_greater_equal.md b/reference/valarray/valarray/op_greater_equal.md
index d88ff7f8f..d15fcb861 100644
--- a/reference/valarray/valarray/op_greater_equal.md
+++ b/reference/valarray/valarray/op_greater_equal.md
@@ -75,7 +75,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;&lt; -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_left_shift.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_left_shift.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_left_shift.md b/reference/valarray/valarray/op_left_shift.md
index a33997609..ff306760f 100644
--- a/reference/valarray/valarray/op_left_shift.md
+++ b/reference/valarray/valarray/op_left_shift.md
@@ -70,7 +70,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt; -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_less.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_less.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_less.md b/reference/valarray/valarray/op_less.md
index 92c500dd0..4d409a7d7 100644
--- a/reference/valarray/valarray/op_less.md
+++ b/reference/valarray/valarray/op_less.md
@@ -75,7 +75,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;= -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_less_equal.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_less_equal.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_less_equal.md b/reference/valarray/valarray/op_less_equal.md
index 8cf301c39..3fde8dbb1 100644
--- a/reference/valarray/valarray/op_less_equal.md
+++ b/reference/valarray/valarray/op_less_equal.md
@@ -75,7 +75,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&amp;&amp; -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_logical_and.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_logical_and.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_logical_and.md b/reference/valarray/valarray/op_logical_and.md
index f9cb8c8aa..0ed6af250 100644
--- a/reference/valarray/valarray/op_logical_and.md
+++ b/reference/valarray/valarray/op_logical_and.md
@@ -80,7 +80,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator|| -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_logical_or.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_logical_or.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_logical_or.md b/reference/valarray/valarray/op_logical_or.md
index 47a6f1800..e73d42838 100644
--- a/reference/valarray/valarray/op_logical_or.md
+++ b/reference/valarray/valarray/op_logical_or.md
@@ -80,7 +80,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator- -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_minus.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_minus.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_minus.md b/reference/valarray/valarray/op_minus.md
index d1081a561..f04eec325 100644
--- a/reference/valarray/valarray/op_minus.md
+++ b/reference/valarray/valarray/op_minus.md
@@ -70,7 +70,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator% -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_modulo.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_modulo.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_modulo.md b/reference/valarray/valarray/op_modulo.md
index 9f3ff99fa..2ed995b0f 100644
--- a/reference/valarray/valarray/op_modulo.md
+++ b/reference/valarray/valarray/op_modulo.md
@@ -70,7 +70,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator* -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_multiply.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_multiply.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_multiply.md b/reference/valarray/valarray/op_multiply.md
index f5068bc7d..5865d2ccf 100644
--- a/reference/valarray/valarray/op_multiply.md
+++ b/reference/valarray/valarray/op_multiply.md
@@ -69,7 +69,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator!= -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_not_equal.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_not_equal.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_not_equal.md b/reference/valarray/valarray/op_not_equal.md
index 981744c7c..6d674937c 100644
--- a/reference/valarray/valarray/op_not_equal.md
+++ b/reference/valarray/valarray/op_not_equal.md
@@ -75,7 +75,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator| -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_or.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_or.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_or.md b/reference/valarray/valarray/op_or.md
index 11be44a3b..a9f290376 100644
--- a/reference/valarray/valarray/op_or.md
+++ b/reference/valarray/valarray/op_or.md
@@ -69,7 +69,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator+ -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_plus.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_plus.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_plus.md b/reference/valarray/valarray/op_plus.md
index 7370c11f6..478750108 100644
--- a/reference/valarray/valarray/op_plus.md
+++ b/reference/valarray/valarray/op_plus.md
@@ -69,7 +69,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&gt;&gt; -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_right_shift.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_right_shift.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_right_shift.md b/reference/valarray/valarray/op_right_shift.md
index d671de213..00126fd8d 100644
--- a/reference/valarray/valarray/op_right_shift.md
+++ b/reference/valarray/valarray/op_right_shift.md
@@ -70,7 +70,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator^ -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/op_xor.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/op_xor.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/op_xor.md b/reference/valarray/valarray/op_xor.md
index d07af9e47..303118afc 100644
--- a/reference/valarray/valarray/op_xor.md
+++ b/reference/valarray/valarray/op_xor.md
@@ -69,7 +69,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pow -- fix(reference/valarray): 表現を単純化</title>
      <link href="https://cpprefjp.github.io/reference/valarray/valarray/pow.html"/>
      <id>49f42e0cbef516023809297e4ff60f77b870b4ab:reference/valarray/valarray/pow.md</id>
      <updated>2025-07-09T23:34:55+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/valarray/valarray/pow.md b/reference/valarray/valarray/pow.md
index 34ad57c9f..bf10ae33d 100644
--- a/reference/valarray/valarray/pow.md
+++ b/reference/valarray/valarray/pow.md
@@ -74,7 +74,7 @@ return result;
 - 引数、および、戻り値の型 *`ValOrProxy`* は、[`valarray`](../valarray.md)、あるいは、その代理となる型である。  
 	[`&amp;lt;valarray&amp;gt;`](../../valarray.md) の概要も参照のこと。
 - (1) : `xs` と `ys` の要素数が異なる場合、未定義動作を引き起こす。
-- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式が型推論に失敗しないようにするためである。  
+- C++20における(2)と(3)に対する変更は、`std::valarray&amp;lt;double&amp;gt;{} * 2` のような式の型推論を可能にするためである。  
 	なお、この変更は規格の誤り修正とみなされているため、処理系によっては C++17 以前でも使用可能となる。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++11 -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp11.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp11.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;C++11&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++11とは、2011年8月に改訂され、ISO/IEC 14882:2011で標準規格化されたC++バージョンの通称である。&lt;/p&gt;
&lt;p&gt;前バージョンであるC++03からメジャーバージョンアップされ、多くの有用な機能が追加された。&lt;/p&gt;
&lt;p&gt;このバージョンは、策定中はC++0xと呼ばれていた。これは、2009年中までに策定を完了させることを目指して、下一桁を伏せ字にしたものである。&lt;/p&gt;
&lt;h2&gt;言語機能&lt;/h2&gt;
&lt;h3&gt;一般的な機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/auto.html&#34;&gt;変数の型推論のための&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型推論&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cpp11/decltype.html&#34;&gt;decltype&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;式の型を取得&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/range_based_for.html&#34;&gt;範囲for文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;配列やコンテナといった範囲を表すオブジェクトを、簡潔に走査する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/initializer_lists.html&#34;&gt;初期化子リスト&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;波カッコによる初期化をユーザー定義する。&lt;code&gt;vector&amp;lt;int&amp;gt; v = {1, 2, 3};&lt;/code&gt;など。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/uniform_initialization.html&#34;&gt;一様初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタの呼び出しを、波カッコで行う。&lt;code&gt;T x {a, b, c};&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/rvalue_ref_and_move_semantics.html&#34;&gt;右辺値参照・ムーブセマンティクス&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;右辺値によるオーバーロード、およびそれによるリソースの所有権移動&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/lambda_expressions.html&#34;&gt;ラムダ式&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクトをその場に書く&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cpp11/noexcept.html&#34;&gt;noexcept&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の例外指定、例外を投げる可能性のある式か&lt;code&gt;bool&lt;/code&gt;値を返す演算子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cpp11/constexpr.html&#34;&gt;constexpr&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定数式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cpp11/nullptr.html&#34;&gt;nullptr&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ヌルポインタを表すポインタリテラル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/inline_namespaces.html&#34;&gt;インライン名前空間&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ネストした名前空間に、透過的にアクセスする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/user_defined_literals.html&#34;&gt;ユーザー定義リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リテラルのサフィックスをユーザー定義する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/defaulted_and_deleted_functions.html&#34;&gt;関数の&lt;code&gt;default&lt;/code&gt;／&lt;code&gt;delete&lt;/code&gt;宣言&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;自動定義される特殊関数の制御&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/delegating_constructors.html&#34;&gt;委譲コンストラクタ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタから他のコンストラクタに処理を委譲する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/non_static_data_member_initializers.html&#34;&gt;非静的メンバ変数の初期化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ変数を、宣言と同時に初期値指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/inheriting_constructors.html&#34;&gt;継承コンストラクタ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;基底クラスのコンストラクタを継承する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/override_final.html&#34;&gt;&lt;code&gt;override&lt;/code&gt;と&lt;code&gt;final&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メンバ関数のオーバーライド指定、および派生クラスでのオーバーライドの禁止を指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/explicit_conversion_operator.html&#34;&gt;明示的な型変換演算子のオーバーロード&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;明示的な型変換が行われる場合にのみ呼び出される演算子をオーバーロードできるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/extend_friend_targets.html&#34;&gt;&lt;code&gt;friend&lt;/code&gt;宣言できる対象を拡張&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータや型の別名を&lt;code&gt;friend&lt;/code&gt;宣言する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/ref_qualifier_for_this.html&#34;&gt;メンバ関数の左辺値／右辺値修飾&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;オブジェクトが左辺値／右辺値の場合のみ呼び出し可能であることの指定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;クラス以外の型に関する機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/scoped_enum.html&#34;&gt;スコープを持つ列挙型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;強い型付けとスコープを持つ列挙型の導入と、それにともなって従来の列挙型を機能拡張&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/unrestricted_unions.html&#34;&gt;共用体でクラスオブジェクトをもつことを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;共用体のメンバ変数として、クラスオブジェクトを持てるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;テンプレート関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/right_angle_brackets.html&#34;&gt;テンプレートでの連続した右山カッコを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector&amp;lt;basic_string&amp;lt;char&amp;gt;&amp;gt;&lt;/code&gt;のように、&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;をスペースを空けずに記述可能にする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cpp11/extern_template.html&#34;&gt;extern template&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートのインスタンス化を抑止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/alias_templates.html&#34;&gt;エイリアステンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレートによって型の別名を定義する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/variadic_templates.html&#34;&gt;可変引数テンプレート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;任意の数のテンプレートパラメータを受け取れるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/local_and_unnamed_type_as_template_arguments.html&#34;&gt;ローカル型と無名型を、テンプレート引数として使用することを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ローカルおよび無名として定義したクラスや列挙型を、テンプレート引数として渡せるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/sfinae_expressions.html&#34;&gt;任意の式によるSFINAE&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;特定の式が有効かどうかで、その関数をオーバーロード解決に含めるかどうかを決定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/remove_export_templates.html&#34;&gt;テンプレートのエクスポート機能を削除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレート定義をエクスポートする機能を削除する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;並行関係の機能&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/thread_local_storage.html&#34;&gt;スレッドローカルストレージ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;スレッドごとに異なる静的記憶域に保持される変数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/static_initialization_thread_safely.html&#34;&gt;ブロックスコープを持つ&lt;code&gt;static&lt;/code&gt;変数初期化のスレッドセーフ化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数ローカルで定義した&lt;code&gt;static&lt;/code&gt;変数の初期化を、スレッドセーフにする&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;その他様々なユーティリティ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/trailing_return_types.html&#34;&gt;戻り値の型を後置する関数宣言構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;戻り値の型を後ろに書けるようにすることで、パラメータオブジェクトを戻り値型の文脈で使用できるようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/static_assert.html&#34;&gt;コンパイル時アサート&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に条件式が真であることを表明する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/raw_string_literals.html&#34;&gt;生文字列リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;文字列リテラルにRプレフィックスを付けることで、エスケープシーケンスを無視する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/char16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;UTF-16とUTF-32の文字型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/utf8_string_literals.html&#34;&gt;UTF-8文字列リテラル&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char&lt;/code&gt;の文字列をUTF-8エンコーディングするプレフィックス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/attributes.html&#34;&gt;属性構文&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[[attr]]&lt;/code&gt;構文による、クラス、関数、変数の属性指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cpp11/alignas.html&#34;&gt;alignas&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメントを指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cpp11/alignof.html&#34;&gt;alignof&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アライメントを取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;小さな変更&lt;/h3&gt;
&lt;p&gt;ここでは、コア言語作業グループへ問題報告され、その解決策として導入された言語仕様の変更を解説する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/predefined_macros.html&#34;&gt;更新された定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準規格で定義されたマクロの更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/feature_test_macros.html&#34;&gt;機能テストマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C++11 の機能がサポートされているかどうかをテストするためのマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/recursive_template_limit.html&#34;&gt;テンプレート再帰回数の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;17回から1024回に制限緩和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/dependent_name_specifier_outside_of_templates.html&#34;&gt;依存名に対する&lt;code&gt;typename&lt;/code&gt;と&lt;code&gt;template&lt;/code&gt;の制限緩和&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;テンプレート外でも&lt;code&gt;typename&lt;/code&gt;と&lt;code&gt;template&lt;/code&gt;を付けられるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/global_scope_syntax_in_nested_name_specifier.html&#34;&gt;入れ子名の指定にグローバルスコープ&lt;code&gt;::&lt;/code&gt;を付加することを許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;struct ::A {};&lt;/code&gt;のように入れ子名を指定する際にグローバルスコープから指定できるようになった&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/earlier_declarated_array_bounds.html&#34;&gt;宣言時に要素数を指定した配列オブジェクトの、定義時の要素数を規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static&lt;/code&gt;メンバや&lt;code&gt;extern&lt;/code&gt;として宣言した配列を定義した際、宣言時に指定した要素数として定義されることが規定された&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/reserved_namespaces_for_posix.html&#34;&gt;POSIX用の名前空間を予約&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将来の標準化のためにPOSIX用の名前空間を予約し、ユーザーがその名前空間で機能を定義することを禁止する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/extending_sizeof_to_apply_to_non_static_data_members_without_an_object.html&#34;&gt;&lt;code&gt;sizeof&lt;/code&gt;演算子にクラスの非静的メンバを、オブジェクトを作らずに指定できるようにする&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof(T::data_member)&lt;/code&gt;のように指定して非静的メンバのサイズを取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/deprecation_of_the_register_keyword.html&#34;&gt;&lt;code&gt;register&lt;/code&gt;キーワードを非推奨化&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コンパイラに使われなくなった最適化用の機能を非推奨化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/reference_collapsing.html&#34;&gt;参照への参照を折りたたむ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp;&lt;/code&gt;型に参照を足しても&lt;code&gt;T&amp;amp;&lt;/code&gt;となる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;C99互換機能&lt;/h3&gt;
&lt;p&gt;C99は、1999年に改訂され、ISO/IEC 9899:1999で標準規格化されたC言語バージョンの通称である。&lt;/p&gt;
&lt;p&gt;C++11では、参照するC言語の規格がC89からC99に変更となり、C99の言語機能が一部、C++に導入された。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/variadic_macros.html&#34;&gt;可変引数マクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;マクロで任意の数の引数を受け取る&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/pragma_operator.html&#34;&gt;Pragma演算子&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;処理系定義の機能を使用する単項演算子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/c99_predefined_macros.html&#34;&gt;定義済みマクロ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;C99互換で導入された定義済みマクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/string_literal_concatenation.html&#34;&gt;文字列リテラルとワイド文字列リテラルの結合&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ワイド文字列定数として結合する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/long_long_type.html&#34;&gt;&lt;code&gt;long long&lt;/code&gt;型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;64ビット以上の大きさを持つ整数型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/func.html&#34;&gt;事前定義識別子&lt;code&gt;__func__&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;現在いる関数名が格納されている識別子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/trailing_comma_following_enumerator_list.html&#34;&gt;列挙子の末尾へのカンマ付加を許可&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;末尾の列挙子の後ろにカンマを書くことが許可された&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;cpp11/result_of_integer_division_and_modulo.html&#34;&gt;整数に対する除算と剰余算の丸め結果を規定&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;これまで処理系定義だった整数の除算と剰余算に対する丸め方法を、標準で規定する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブラリ更新の概要&lt;/h2&gt;
&lt;h3&gt;コンテナ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;固定長配列クラス&lt;code&gt;&lt;a href=&#34;../reference/array/array.html&#34;&gt;std::array&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;単方向リンクリストの実装である&lt;code&gt;&lt;a href=&#34;../reference/forward_list.html&#34;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ハッシュ表の連想コンテナである&lt;code&gt;&lt;a href=&#34;../reference/unordered_map/unordered_map.html&#34;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/unordered_set/unordered_set.html&#34;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;クラス、およびその重複を許可するバージョンを追加&lt;/li&gt;
&lt;li&gt;コンテナ全般がムーブセマンティクスに対応&lt;ul&gt;
&lt;li&gt;クラステンプレートのパラメータ&lt;code&gt;T&lt;/code&gt;が、コピー構築可能な型だけでなく、ムーブ構築のみ可能な型も受け付けるようになった&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push_back()&lt;/code&gt;や&lt;code&gt;insert()&lt;/code&gt;等の要素追加のためのメンバ関数が、新たな要素のコピーだけでなく、一時オブジェクトも受け取れて、ムーブで挿入ができるようになった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要素追加のためのメンバ関数として、クラステンプレートのパラメータ&lt;code&gt;T&lt;/code&gt;のコンストラクタ引数を受け取り、一時オブジェクトの生成コストを減らせるものが追加された。これらは、以下のように命名されたメンバ関数である：&lt;code&gt;emplace()&lt;/code&gt;、&lt;code&gt;emplace_back()&lt;/code&gt;、&lt;code&gt;emplace_front()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;コンテナのメモリアロケータが状態を持てるようになった&lt;/li&gt;
&lt;li&gt;初期化子リストでコンテナを初期化できるようになった&lt;/li&gt;
&lt;li&gt;初期化子リストをパラメータで受け取れるようにするためのクラス&lt;code&gt;&lt;a href=&#34;../reference/initializer_list/initializer_list.html&#34;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;型情報型を連想コンテナのキーとして使用するための&lt;code&gt;&lt;a href=&#34;../reference/typeindex/type_index.html&#34;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イテレータ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;イテレータを進める関数&lt;code&gt;&lt;a href=&#34;../reference/iterator/next.html&#34;&gt;std::next()&lt;/a&gt;&lt;/code&gt;、イテレータを逆に進める関数&lt;code&gt;&lt;a href=&#34;../reference/iterator/prev.html&#34;&gt;std::prev()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;要素をムーブするイテレータとして、&lt;code&gt;&lt;a href=&#34;../reference/iterator/move_iterator.html&#34;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;先頭イテレータと末尾イテレータを取得する非メンバ関数として、&lt;code&gt;&lt;a href=&#34;../reference/iterator/begin.html&#34;&gt;std::begin()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/iterator/end.html&#34;&gt;std::end()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アルゴリズム&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;イテレータ範囲が特定の条件を満たしているか調べる、&lt;code&gt;&lt;a href=&#34;../reference/algorithm/all_of.html&#34;&gt;std::all_of()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/algorithm/any_of.html&#34;&gt;std::any_of()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/algorithm/none_of.html&#34;&gt;std::none_of&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件を満たしていない最初の要素を検索する&lt;code&gt;&lt;a href=&#34;../reference/algorithm/find_if_not.html&#34;&gt;std::find_if_not()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定された数の要素をコピーする&lt;code&gt;&lt;a href=&#34;../reference/algorithm/copy_n.html&#34;&gt;std::copy_n()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件を満たす要素のみをコピーする&lt;code&gt;&lt;a href=&#34;../reference/algorithm/copy_if.html&#34;&gt;std::copy_if()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータ範囲の要素をムーブする&lt;code&gt;&lt;a href=&#34;../reference/algorithm/move.html&#34;&gt;std::move()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/algorithm/move_backward.html&#34;&gt;std::move_backward()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;新たな乱数ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;に対応したイテレータ範囲のシャッフルアルゴリズム&lt;code&gt;&lt;a href=&#34;../reference/algorithm/shuffle.html&#34;&gt;std::shuffle()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;イテレータ範囲がソート済みか調べる&lt;code&gt;&lt;a href=&#34;../reference/algorithm/is_sorted.html&#34;&gt;std::is_sorted()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;2つの値の最小値を取得する&lt;code&gt;&lt;a href=&#34;../reference/algorithm/min.html&#34;&gt;std::min()&lt;/a&gt;&lt;/code&gt;、最大値を取得する&lt;code&gt;&lt;a href=&#34;../reference/algorithm/max.html&#34;&gt;std::max()&lt;/a&gt;&lt;/code&gt;に、初期化子リストによる可変引数版を追加&lt;/li&gt;
&lt;li&gt;最小値と最大値を同時に取得する関数&lt;code&gt;&lt;a href=&#34;../reference/algorithm/minmax.html&#34;&gt;std::minmax()&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/algorithm/minmax_element.html&#34;&gt;std::minmax_element()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;指定された値から始まる整数列を生成する&lt;code&gt;&lt;a href=&#34;../reference/numeric/iota.html&#34;&gt;std::iota()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;メモリ管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;メモリアロケータの実装をより容易にするために、コンテナとメモリアロケータの中間インタフェースとして&lt;code&gt;&lt;a href=&#34;../reference/memory/allocator_traits.html&#34;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スマートポインタの実装として、所有権共有方式の&lt;code&gt;&lt;a href=&#34;../reference/memory/shared_ptr.html&#34;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;クラスと、所有権専有方式の&lt;code&gt;&lt;a href=&#34;../reference/memory/unique_ptr.html&#34;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;従来のスマートポインタ&lt;code&gt;auto_ptr&lt;/code&gt;クラスを、非推奨とする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator&amp;amp;()&lt;/code&gt;がオーバーロードされていたとしても正しく変数のアドレスを取得する関数、&lt;code&gt;&lt;a href=&#34;../reference/memory/addressof.html&#34;&gt;std::addressof()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;入出力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;標準ライブラリ中の入力ストリーム演算子&lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;と出力ストリーム演算子&lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;がムーブセマンティクスに対応。ストリームの一時オブジェクトを受け取れるようになった&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文字列処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UTF-16の文字列型&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::u16string&lt;/a&gt;&lt;/code&gt;、UTF-32の文字列型&lt;code&gt;&lt;a href=&#34;../reference/string/basic_string.html&#34;&gt;std::u32string&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;UTF-8とUTF-16、UTF-8とUTF-32といった、マルチバイト文字とワイド文字列の相互変換を行うクラス&lt;code&gt;&lt;a href=&#34;../reference/locale/wstring_convert.html&#34;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;数値から文字列オブジェクトに変換する関数として、&lt;code&gt;&lt;a href=&#34;../reference/string/to_string.html&#34;&gt;std::to_string()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/string/to_wstring.html&#34;&gt;std::to_wstring()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;文字列オブジェクトから数値に変換する、&lt;code&gt;&lt;a href=&#34;../reference/string/stoi.html&#34;&gt;std::stoi()&lt;/a&gt;&lt;/code&gt;や&lt;code&gt;&lt;a href=&#34;../reference/string/stof.html&#34;&gt;std::stof()&lt;/a&gt;&lt;/code&gt;といった関数を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;関数オブジェクト&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;関数ポインタと関数オブジェクトを統一的に扱えるクラス&lt;code&gt;&lt;a href=&#34;../reference/functional/function.html&#34;&gt;std::function&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;関数の引数を束縛して部分適用する関数&lt;code&gt;&lt;a href=&#34;../reference/functional/bind.html&#34;&gt;std::bind()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;メンバ関数ポインタを関数オブジェクトにアダプトする関数&lt;code&gt;&lt;a href=&#34;../reference/functional/mem_fn.html&#34;&gt;std::mem_fn()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;テンプレートに、明示的に左辺値参照を渡すための渡すためのクラス&lt;code&gt;&lt;a href=&#34;../reference/functional/reference_wrapper.html&#34;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;と、そのヘルパ関数である&lt;code&gt;&lt;a href=&#34;../reference/functional/ref.html&#34;&gt;std::ref()&lt;/a&gt;&lt;/code&gt;と&lt;code&gt;&lt;a href=&#34;../reference/functional/cref.html&#34;&gt;std::cref()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ハッシュ表コンテナの追加にともない、オブジェクトのハッシュ値を計算する関数オブジェクト&lt;code&gt;&lt;a href=&#34;../reference/functional/hash.html&#34;&gt;std::hash&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;ビット演算の関数オブジェクトとして、&lt;code&gt;&lt;a href=&#34;../reference/functional/bit_and.html&#34;&gt;std::bit_and&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/functional/bit_or.html&#34;&gt;std::bit_or&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/functional/bit_xor.html&#34;&gt;std::bit_xor&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;従来の関数オブジェクトアダプタ&lt;code&gt;std::unary_function&lt;/code&gt;、&lt;code&gt;std::binary_function&lt;/code&gt;、&lt;code&gt;std::mem_fun()&lt;/code&gt;、&lt;code&gt;std::mem_fun_ref()&lt;/code&gt;等を非推奨とする&lt;/li&gt;
&lt;li&gt;従来の関数バインダ&lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;等を非推奨とする&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並行処理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;スレッドを管理するクラス&lt;code&gt;&lt;a href=&#34;../reference/thread/thread.html&#34;&gt;std::thread&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;スレッド間での排他制御を行うミューテックスの実装である&lt;code&gt;&lt;a href=&#34;../reference/mutex/mutex.html&#34;&gt;std::mutex&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/mutex/recursive_mutex.html&#34;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt;クラス等を追加&lt;ul&gt;
&lt;li&gt;ミューテックスの所有権放棄を自動的に行うためのクラス&lt;code&gt;&lt;a href=&#34;../reference/mutex/lock_guard.html&#34;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;、&lt;code&gt;&lt;a href=&#34;../reference/mutex/unique_lock.html&#34;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;スレッドセーフに一度だけ処理を呼び出す関数、&lt;code&gt;&lt;a href=&#34;../reference/mutex/call_once.html&#34;&gt;std::call_once()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;条件変数の実装である&lt;code&gt;&lt;a href=&#34;../reference/condition_variable/condition_variable.html&#34;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/condition_variable/condition_variable_any.html&#34;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;Futureデザインパターンをサポートする&lt;code&gt;&lt;a href=&#34;../reference/future/future.html&#34;&gt;std::future&lt;/a&gt;&lt;/code&gt;クラス、&lt;code&gt;&lt;a href=&#34;../reference/future/promise.html&#34;&gt;std::promise&lt;/a&gt;&lt;/code&gt;クラス、およびその補助機能を追加&lt;/li&gt;
&lt;li&gt;アトミック操作のライブラリ&lt;code&gt;&lt;a href=&#34;../reference/atomic.html&#34;&gt;&amp;lt;atomic&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;汎用的なユーティリティ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::swap()&lt;/code&gt;関数を、&lt;code&gt;&lt;a href=&#34;../reference/algorithm.html&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/a&gt;&lt;/code&gt;から&lt;code&gt;&lt;a href=&#34;../reference/utility.html&#34;&gt;&amp;lt;utility&amp;gt;&lt;/a&gt;&lt;/code&gt;に移動&lt;/li&gt;
&lt;li&gt;ムーブセマンティクスのために、左辺値を右辺値に変換する関数&lt;code&gt;&lt;a href=&#34;../reference/utility/move.html&#34;&gt;std::move()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;引数転送のための関数&lt;code&gt;&lt;a href=&#34;../reference/utility/forward.html&#34;&gt;std::forward()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;../reference/utility/pair.html&#34;&gt;std::pair&lt;/a&gt;&lt;/code&gt;クラスの&lt;a href=&#34;../reference/utility/pair/op_constructor.html&#34;&gt;コンストラクタ&lt;/a&gt;が、それぞれの要素型のコンストラクタ引数を直接受け取れるようになった&lt;/li&gt;
&lt;li&gt;タプルの実装である&lt;code&gt;&lt;a href=&#34;../reference/tuple/tuple.html&#34;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;li&gt;SFINAEのために、型の値を取得する関数&lt;code&gt;&lt;a href=&#34;../reference/utility/declval.html&#34;&gt;std::declval()&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;時間ユーティリティライブラリ&lt;code&gt;&lt;a href=&#34;../reference/chrono.html&#34;&gt;&amp;lt;chrono&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;型特性ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/type_traits.html&#34;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;エラー報告&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OSのエラー値を扱うライブラリ&lt;code&gt;&lt;a href=&#34;../reference/system_error.html&#34;&gt;&amp;lt;system_error&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;正規表現ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正規表現ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/regex.html&#34;&gt;&amp;lt;regex&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;ECMAScript、POSIX、AWK、grepなどの構文を切り替えて使用できるのが特徴。デフォルトではECMAScript&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;乱数ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;乱数ライブラリ&lt;code&gt;&lt;a href=&#34;../reference/random.html&#34;&gt;&amp;lt;random&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;複数定義されている乱数生成器と分布アルゴリズムを、組み合わせて使用するのが特徴&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C互換ライブラリ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ビット幅規定の整数型ライブラリである&lt;code&gt;&lt;a href=&#34;../reference/cstdint.html&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/a&gt;&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/cpp11&#34; target=&#34;_blank&#34;&gt;C++11 Overview - Standard C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>char16_tとchar32_t [N2249] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/char16_32.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp11/char16_32.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/char16_32.md b/lang/cpp11/char16_32.md
index 4364f5d20..4558b51fd 100644
--- a/lang/cpp11/char16_32.md
+++ b/lang/cpp11/char16_32.md
@@ -38,18 +38,18 @@ char16_t s[] = u&amp;#34;\U00020BB7野家&amp;#34;; // 𠮷野家
     - ひとつの文字を含む`char16_t`リテラルの値は、ひとつの16ビットコードポイントで表現できるISO 10646のコードポイント値と同じである。
     - ひとつの値を16ビットで表現できない場合、プログラムは不適格となる。
     - 複数の文字を含む`char16_t`文字リテラルは不適格である。
-    - `char16_t`文字リテラルが、基本文字集合とユニバーサルキャラクタ名より多くを含む場合は実装定義となる。
+    - `char16_t`文字リテラルが、基本文字集合とユニバーサルキャラクタ名より多くを含む場合は処理系定義となる。
     - `char16_t`の場合、ひとつの文字がひとつ以上の`char16_t`を生成することがある。その文字はサロゲートペアと呼ばれる。
     - `char16_t`型の文字列リテラルは、静的ストレージに配置される。
 - `U`プレフィックスが付く文字リテラルの型は`char32_t`であり、`U`プレフィックスが付く文字列リテラルの要素型は`char32_t`である。
     - ひとつの文字を含む`char32_t`リテラルの値は、ひとつの32ビットコードポイントで表現できるISO 10646のコードポイント値と同じである。
     - ひとつの値を32ビットで表現できない場合、プログラムは不適格となる。
     - 複数の文字を含む`char32_t`文字リテラルは不適格である。
-    - `char32_t`文字リテラルが、基本文字集合とユニバーサルキャラクタ名より多くを含む場合は実装定義となる。
+    - `char32_t`文字リテラルが、基本文字集合とユニバーサルキャラクタ名より多くを含む場合は処理系定義となる。
     - `char32_t`型の文字列リテラルは、静的ストレージに配置される。
 - `char16_t`と`char32_t`はそれぞれ、[`&amp;lt;cstdint&amp;gt;`](/reference/cstdint.md)ヘッダで定義される[`uint_least16_t`](/reference/cstdint/uint_least16_t.md)と[`uint_least32_t`](/reference/cstdint/uint_least32_t.md)と、サイズ、符号の有無、アライメントが同じである。
-- `&amp;lt;cuchar&amp;gt;`ヘッダでマクロ`__STDC_UTF_16__`が定義される場合、`char16_t`型の値はUTF-16の妥当なコードポイントを持つ。そうでない場合、`char16_t`型の値は実装定義の文字コードとなる。
-- `&amp;lt;cuchar&amp;gt;`ヘッダでマクロ`__STDC_UTF_32__`が定義される場合、`char32_t`型の値はUTF-32の妥当なコードポイントを持つ。そうでない場合、`char32_t`型の値は実装定義の文字コードとなる。
+- `&amp;lt;cuchar&amp;gt;`ヘッダでマクロ`__STDC_UTF_16__`が定義される場合、`char16_t`型の値はUTF-16の妥当なコードポイントを持つ。そうでない場合、`char16_t`型の値は処理系定義の文字コードとなる。
+- `&amp;lt;cuchar&amp;gt;`ヘッダでマクロ`__STDC_UTF_32__`が定義される場合、`char32_t`型の値はUTF-32の妥当なコードポイントを持つ。そうでない場合、`char32_t`型の値は処理系定義の文字コードとなる。
 
 
 ### ユニバーサルキャラクタ名
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>事前定義識別子__func__ [N1653] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/func.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp11/func.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/func.md b/lang/cpp11/func.md
index e6a6baa91..b7c40b922 100644
--- a/lang/cpp11/func.md
+++ b/lang/cpp11/func.md
@@ -23,7 +23,7 @@ static const char __func__[] = &amp;#34;function-name&amp;#34;;
 ```
 * function-name[italic]
 
-`&amp;#34;function-name&amp;#34;`には、実装定義の文字列が格納される。そのため、マングリングされた関数名、オーバーロード、名前空間、所属するクラスなどの扱いは、実装ごとに異なる可能性がある。多くの場合、`__func__`には関数の名前のみが格納され、名前空間名、クラス名、戻り値の型やパラメータといった情報は含まれない。
+`&amp;#34;function-name&amp;#34;`には、処理系定義の文字列が格納される。そのため、マングリングされた関数名、オーバーロード、名前空間、所属するクラスなどの扱いは、実装ごとに異なる可能性がある。多くの場合、`__func__`には関数の名前のみが格納され、名前空間名、クラス名、戻り値の型やパラメータといった情報は含まれない。
 
 
 変数`__func__`が、プログラム内の他の変数と異なるアドレスを持っているかどうかは未規定。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>整数に対する除算と剰余算の丸め結果を規定 -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/result_of_integer_division_and_modulo.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp11/result_of_integer_division_and_modulo.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/result_of_integer_division_and_modulo.md b/lang/cpp11/result_of_integer_division_and_modulo.md
index 3408e1c7b..9a76f9e0f 100644
--- a/lang/cpp11/result_of_integer_division_and_modulo.md
+++ b/lang/cpp11/result_of_integer_division_and_modulo.md
@@ -10,7 +10,7 @@
 &amp;lt;!-- last lang caution --&amp;gt;
 
 ## 概要
-整数`a`, `b`に対する除算`a/b`の結果(商)と剰余算`a%b`の結果(余り)について`(a/b)*b + a%b = a`という等式が成り立つことが規定されているが、C++03まで、少なくとも一方が負の数である場合の余りの符号は実装定義だった。このため先述の等式により商も実装定義となっていた。C++11ではC99に合わせて「商の小数部がゼロ方向に切り捨てられた結果となること」が規定された。
+整数`a`, `b`に対する除算`a/b`の結果(商)と剰余算`a%b`の結果(余り)について`(a/b)*b + a%b = a`という等式が成り立つことが規定されているが、C++03まで、少なくとも一方が負の数である場合の余りの符号は処理系定義だった。このため先述の等式により商も処理系定義となっていた。C++11ではC99に合わせて「商の小数部がゼロ方向に切り捨てられた結果となること」が規定された。
 
 これにより、整数に対する除算と剰余算の結果が移植性のある値となるようになった。
 
@@ -18,7 +18,7 @@
 ## 仕様
 C++03では、余りの符号が以下のように規定されていた：
 
-「両方の項が非負である場合、余りは非負となる。片方もしくは両方の項が負数である場合、余りの符号は実装定義となる。注釈：現在作業中のISO Cのリビジョン(C99のこと)とISO/IEC 1539:1991で標準化されているFortranの規格ではいずれも、整数に対する除算の商は必ずゼロ方向に丸められる。」
+「両方の項が非負である場合、余りは非負となる。片方もしくは両方の項が負数である場合、余りの符号は処理系定義となる。注釈：現在作業中のISO Cのリビジョン(C99のこと)とISO/IEC 1539:1991で標準化されているFortranの規格ではいずれも、整数に対する除算の商は必ずゼロ方向に丸められる。」
 
 C++11では、C99との互換性のために、上記規定を置き換えて、整数に対する除算の結果が以下のように規定された：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>スコープを持つ列挙型 [N2347] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/scoped_enum.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp11/scoped_enum.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/scoped_enum.md b/lang/cpp11/scoped_enum.md
index 7b712f5e3..70e52a521 100644
--- a/lang/cpp11/scoped_enum.md
+++ b/lang/cpp11/scoped_enum.md
@@ -41,7 +41,7 @@ int color = static_cast&amp;lt;int&amp;gt;(Color::Red);
 
 - 列挙型は、先行宣言でも基底型を指定できる。その場合、再宣言および定義でも、同じ基底型を明示的に指定する必要がある
 - スコープを持つ列挙型に基底型を指定しない場合、基底型は`int`となる
-- スコープを持たない列挙型に基底型を指定しない場合、その列挙型の全ての列挙子の値を表現できる整数型のいずれかが基底型となる（どの整数型となるかは実装定義だが、すべての列挙子の値が`int`もしくは`unsigned int`に収まる限り`int`より大きな型にはならない）
+- スコープを持たない列挙型に基底型を指定しない場合、その列挙型の全ての列挙子の値を表現できる整数型のいずれかが基底型となる（どの整数型となるかは処理系定義だが、すべての列挙子の値が`int`もしくは`unsigned int`に収まる限り`int`より大きな型にはならない）
 - スコープを持たない列挙型の列挙子が空である場合、値`0`ひとつを列挙子として持つ
 - 2つの列挙型の基底型が同じである場合、それらの列挙型は互換性のあるメモリレイアウトを持つ
 - 列挙子に値を指定しない場合、最初の列挙子には定数値`0`が設定される。2つ目以降の列挙子は、ひとつ前の値を`1`進めた値を持つ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>UTF-8文字列リテラル [N2442] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp11/utf8_string_literals.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp11/utf8_string_literals.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp11/utf8_string_literals.md b/lang/cpp11/utf8_string_literals.md
index 919685ca1..efdf56968 100644
--- a/lang/cpp11/utf8_string_literals.md
+++ b/lang/cpp11/utf8_string_literals.md
@@ -21,7 +21,7 @@ char s[] = u8&amp;#34;あいうえお&amp;#34;;
 char t[] = u8&amp;#34;\U00020BB7野家&amp;#34;; // 𠮷野家
 ```
 
-`u8`プレフィックスを指定しない場合は、実装定義のマルチバイト文字コードにエンコードされる。その実装定義の文字コードは、ASCII文字コードと互換があることは保証されない。そのため、UTF-8のASCII互換部分が、実装定義の文字コードと互換があることも、保証されない。
+`u8`プレフィックスを指定しない場合は、処理系定義のマルチバイト文字コードにエンコードされる。その処理系定義の文字コードは、ASCII文字コードと互換があることは保証されない。そのため、UTF-8のASCII互換部分が、処理系定義の文字コードと互換があることも、保証されない。
 
 C++20ではUTF-8文字リテラルの型が[`const char[N]`ではなく`const char8_t[N]`になる](/lang/cpp20/char8_t.md)
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>[[deprecated]]属性 [N3760] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp14/deprecated_attr.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp14/deprecated_attr.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp14/deprecated_attr.md b/lang/cpp14/deprecated_attr.md
index 0dfa33f04..69eaaaed0 100644
--- a/lang/cpp14/deprecated_attr.md
+++ b/lang/cpp14/deprecated_attr.md
@@ -39,8 +39,8 @@ int main()
 - `[[deprecated]]`属性の引数は、なにも指定しないか、もしくは文字列リテラルを指定するかのどちらかである
     - 引数なしの場合は、`[[deprecated]]`と記述する
 	- 文字列リテラルを指定する場合は、`[[deprecated(&amp;#34;message&amp;#34;)]]`のように記述する
-- 引数の文字列リテラルの扱いはコンパイラの実装定義だが、多くの場合、指定した文字列を、コンパイル時の警告として出力するだろう
-    - 文字列リテラルの文字コードもまた、コンパイラの実装定義である
+- 引数の文字列リテラルの扱いはコンパイラの処理系定義だが、多くの場合、指定した文字列を、コンパイル時の警告として出力するだろう
+    - 文字列リテラルの文字コードもまた、コンパイラの処理系定義である
 - この属性は、以下の宣言に対して適用できることがコンパイラに推奨される：
     - クラス
     - 型の別名
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>更新された定義済みマクロ -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp17/predefined_macros.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp17/predefined_macros.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;更新された定義済みマクロ&lt;/span&gt;&lt;span class=&#34;cpp cpp17&#34; title=&#34;C++17で追加&#34;&gt;(C++17)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;このページはC++17に採用された言語機能の変更を解説しています。&lt;/p&gt;
&lt;p&gt;のちのC++規格でさらに変更される場合があるため&lt;a href=&#34;#relative-page&#34;&gt;関連項目&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;定義済みマクロの値が、以下のように更新された：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;マクロ名&lt;/th&gt;
&lt;th&gt;値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__cplusplus&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;201703L&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++のバージョン値を表す&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;新規マクロは以下：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;マクロ名&lt;/th&gt;
&lt;th&gt;値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;処理系定義&lt;/td&gt;
&lt;td&gt;動的メモリ確保時のデフォルトのアライメント値&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;#relative-page&#34; id=&#34;relative-page&#34;&gt;関連項目&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;dynamic_memory_allocation_for_over-aligned_data.html&#34;&gt;C++17 アライメント指定されたデータの動的メモリ確保&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>char16_tとchar32_tの文字・文字列リテラルを、文字コードUTF-16/32に規定 [P1041R4] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/make_char16t_char32t_string_literals_be_utf16_32.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp20/make_char16t_char32t_string_literals_be_utf16_32.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;char16_tとchar32_tの文字・文字列リテラルを、文字コードUTF-16/32に規定 [P1041R4]&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;このページはC++20に採用された言語機能の変更を解説しています。&lt;/p&gt;
&lt;p&gt;のちのC++規格でさらに変更される場合があるため&lt;a href=&#34;#relative-page&#34;&gt;関連項目&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++11で追加された文字型&lt;a href=&#34;../cpp11/char16_32.html&#34;&gt;&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;&lt;/a&gt;の文字・文字列リテラルの文字コード、C++20からはUTF-16とUTF-32であることが規定される。&lt;/p&gt;
&lt;p&gt;これまでは、以下のような仕様であった：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;cuchar&amp;gt;&lt;/code&gt;ヘッダでマクロ&lt;code&gt;__STDC_UTF_16__&lt;/code&gt;が定義される場合、&lt;code&gt;char16_t&lt;/code&gt;型の値はUTF-16の妥当なコードポイントを持つ。そうでない場合、&lt;code&gt;char16_t&lt;/code&gt;型の値は処理系定義の文字コードとなる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;cuchar&amp;gt;&lt;/code&gt;ヘッダでマクロ&lt;code&gt;__STDC_UTF_32__&lt;/code&gt;が定義される場合、&lt;code&gt;char32_t&lt;/code&gt;型の値はUTF-32の妥当なコードポイントを持つ。そうでない場合、&lt;code&gt;char32_t&lt;/code&gt;型の値は処理系定義の文字コードとなる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++20では、無条件にUTF-16とUTF-32であることが規定される。&lt;/p&gt;
&lt;p&gt;なお、&lt;code&gt;u8&lt;/code&gt;プレフィックスをつけた文字・文字列リテラルは、UTF-8であることがこれまでに規定されていた。&lt;/p&gt;
&lt;h2&gt;この機能が必要になった背景・経緯&lt;/h2&gt;
&lt;p&gt;これまで、&lt;code&gt;&amp;lt;cuchar&amp;gt;&lt;/code&gt;ヘッダのマクロ&lt;code&gt;__STDC_UTF_16__&lt;/code&gt;と&lt;code&gt;__STDC_UTF_32__&lt;/code&gt;が定義されている場合にのみ、&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;はUTF-16/UTF-32エンコーディングであると規定されていた。&lt;/p&gt;
&lt;p&gt;しかし、これらが定義されなかった場合にコンパイラがほかのエンコーディングを選択することが疑わしかった。また、&lt;code&gt;char16_t&lt;/code&gt;の仕様として「サロゲートペア」が含まれているが、その概念をもつ他のよく知られた文字コードはない。単一の文字を32ビットで表現する他のよく知られた文字コードもない。&lt;/p&gt;
&lt;p&gt;実際にはすべての実装でこれらの文字・文字列リテラルはUTF-16とUTF-32にエンコーディングされるため、要件を示すだけではなく、より明確にするために、&lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;の文字・文字列リテラルがUTF-16とUTF-32文字コードであることを規定する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;#relative-page&#34; id=&#34;relative-page&#34;&gt;関連項目&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../cpp11/char16_32.html&#34;&gt;C++11 &lt;code&gt;char16_t&lt;/code&gt;と&lt;code&gt;char32_t&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../cpp11/utf8_string_literals.html&#34;&gt;C++11 UTF-8文字列リテラル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../cpp17/utf8_character_literals.html&#34;&gt;C++17 UTF-8文字リテラル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1041r4.html&#34; target=&#34;_blank&#34;&gt;P1041R4 Make &lt;code&gt;char16_t&lt;/code&gt;/&lt;code&gt;char32_t&lt;/code&gt; string literals be UTF-16/32&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>可変サイズをもつコンテナのconstexpr化 [P0784R7] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/more_constexpr_containers.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp20/more_constexpr_containers.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/more_constexpr_containers.md b/lang/cpp20/more_constexpr_containers.md
index 36010cc6e..a713fd45c 100644
--- a/lang/cpp20/more_constexpr_containers.md
+++ b/lang/cpp20/more_constexpr_containers.md
@@ -156,7 +156,7 @@ constexpr void f() {
 }
 ```
 
-実際にはどこのストレージが提供されるかは実装定義である。
+実際にはどこのストレージが提供されるかは処理系定義である。
 
 ### `std::allocator/std::allocator_traits`
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>constexpr関数内でのトリビアルなデフォルト初期化を許可 [P1331R2] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.md b/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.md
index 2a6192d39..fd3220569 100644
--- a/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.md
+++ b/lang/cpp20/permitting_trivial_default_initialization_in_constexpr_contexts.md
@@ -11,7 +11,7 @@
 
 ## 概要
 
-型`T`の変数を単に`T t;`のように（関数スコープで）初期化した時、`T`がクラス型であり非トリビアルなデフォルトコンストラクタを持っているか、集成体型であり全てのメンバがデフォルトメンバ初期化によって初期化されていれば、`t`は初期化されており値は決定的である。しかし、組み込み型など[トリビアルにデフォルト構築可能](/reference/type_traits/is_trivially_default_constructible.md)な型の場合はその初期化は実装定義であり、その値の読み取りは未定義動作である。
+型`T`の変数を単に`T t;`のように（関数スコープで）初期化した時、`T`がクラス型であり非トリビアルなデフォルトコンストラクタを持っているか、集成体型であり全てのメンバがデフォルトメンバ初期化によって初期化されていれば、`t`は初期化されており値は決定的である。しかし、組み込み型など[トリビアルにデフォルト構築可能](/reference/type_traits/is_trivially_default_constructible.md)な型の場合はその初期化は処理系定義であり、その値の読み取りは未定義動作である。
 
 定数式には未定義動作が含まれてはならない事から、`constexpr`関数内のローカル変数が初期化されておらずその関数がコンパイル時に実行された場合、C++17までは不定な値が読み取られているかに関わらずコンパイルエラーとなっていた。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>文字リテラルエンコーディングを一貫させる [P2316R2] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/consistent_character_literal_encoding.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp23/consistent_character_literal_encoding.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/consistent_character_literal_encoding.md b/lang/cpp23/consistent_character_literal_encoding.md
index 6e935b573..29f7ddf37 100644
--- a/lang/cpp23/consistent_character_literal_encoding.md
+++ b/lang/cpp23/consistent_character_literal_encoding.md
@@ -19,7 +19,7 @@ C++20までは、以下のような、プリプロセッサ上での文字リテ
 if (&amp;#39;A&amp;#39; == 0x41){}
 ```
 
-プリプロセッサとそれ以外の文字列リテラルの解釈が一致するかどうかは実装定義となっていたが、これをプリプロセッサの文字列リテラルの解釈がプリプロセッサ外と一致するよう規定する。
+プリプロセッサとそれ以外の文字列リテラルの解釈が一致するかどうかは処理系定義となっていたが、これをプリプロセッサの文字列リテラルの解釈がプリプロセッサ外と一致するよう規定する。
 
 
 ## この機能が必要になった背景・経緯
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>異なる文字エンコーディングをもつ文字列リテラルの連結を不適格とする [P2201R1] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/mixed_string_literal_concatenation.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp23/mixed_string_literal_concatenation.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/mixed_string_literal_concatenation.md b/lang/cpp23/mixed_string_literal_concatenation.md
index 852d6d4ab..07c5905b6 100644
--- a/lang/cpp23/mixed_string_literal_concatenation.md
+++ b/lang/cpp23/mixed_string_literal_concatenation.md
@@ -10,10 +10,10 @@
 &amp;lt;!-- last lang caution --&amp;gt;
 
 ## 概要
-C++20までは、実装定義の動作として`L&amp;#34;&amp;#34;`、`u8&amp;#34;&amp;#34;`、`u&amp;#34;&amp;#34;`、`U&amp;#34;&amp;#34;`のようなエンコーディングが混在する文字列リテラルの連結を条件付きで許可していたが、これを禁止とする。
+C++20までは、処理系定義の動作として`L&amp;#34;&amp;#34;`、`u8&amp;#34;&amp;#34;`、`u&amp;#34;&amp;#34;`、`U&amp;#34;&amp;#34;`のようなエンコーディングが混在する文字列リテラルの連結を条件付きで許可していたが、これを禁止とする。
 
 ```cpp
-// C++20 : 実装定義として条件付きでOK
+// C++20 : 処理系定義として条件付きでOK
 //         (ただし主要コンパイラはサポートしていない)
 // C++23 : NG
 void f() {
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>1ワイド文字に収まらないワイド文字リテラルを禁止する [P2362R3] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/remove_non_encodable_wide_character_literals_and_multicharacter_wide_character_literals.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp23/remove_non_encodable_wide_character_literals_and_multicharacter_wide_character_literals.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/remove_non_encodable_wide_character_literals_and_multicharacter_wide_character_literals.md b/lang/cpp23/remove_non_encodable_wide_character_literals_and_multicharacter_wide_character_literals.md
index 440c3dce7..cdeaede0f 100644
--- a/lang/cpp23/remove_non_encodable_wide_character_literals_and_multicharacter_wide_character_literals.md
+++ b/lang/cpp23/remove_non_encodable_wide_character_literals_and_multicharacter_wide_character_literals.md
@@ -25,7 +25,7 @@ wchar_t c = L&amp;#39;é&amp;#39;;  // C++20:OK, C++23:NG \u0065\u0301
 変数`a`のケースは`wchar_t`が32ビットの環境では情報を損うことなく表現でき、16ビットの環境では上位16ビットか下位16ビットのどちらかが切り捨てられる実装がある。
 `a`のケースは32ビットの場合には正しいものであるため、C++23では維持される。
 
-変数`b`のケースはマルチキャラクタリテラル (multi-character literals) であり、実装定義の値となるが、多くの環境でいずれか1文字の値のみが使われていた。また、韓国語やバラモン語では1文字に見えて複数文字であるような場合があるため、`wchar_t`にマルチキャラクタリテラルを許可することはバグの元であるため、禁止とする。
+変数`b`のケースはマルチキャラクタリテラル (multi-character literals) であり、処理系定義の値となるが、多くの環境でいずれか1文字の値のみが使われていた。また、韓国語やバラモン語では1文字に見えて複数文字であるような場合があるため、`wchar_t`にマルチキャラクタリテラルを許可することはバグの元であるため、禁止とする。
 
 変数`c`のケースは1文字のように見えても複数のコードポイントで構成されており、マルチキャラクタリテラルの一種であるため禁止とする。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>汎用的なソースコードのエンコーディングとしてUTF-8をサポート [P2295R6] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/support_for_utf8_as_a_portable_source_file_encoding.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp23/support_for_utf8_as_a_portable_source_file_encoding.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;汎用的なソースコードのエンコーディングとしてUTF-8をサポート [P2295R6]&lt;/span&gt;&lt;span class=&#34;cpp cpp23&#34; title=&#34;C++23で追加&#34;&gt;(C++23)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;このページはC++23に採用された言語機能の変更を解説しています。&lt;/p&gt;
&lt;p&gt;のちのC++規格でさらに変更される場合があるため&lt;a href=&#34;#relative-page&#34;&gt;関連項目&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;C++20まで、ソースコードの文字集合は処理系定義だったが、その仕様では移植性に問題があった。C++23からは、すべてのコンパイラはUTF-8文字コードのソースコードをサポートしなければならないことが規定される。&lt;/p&gt;
&lt;p&gt;コンパイラは、ほかの文字コードと区別するため、入力ファイルがUTF-8であることを決定する処理系定義の手段をもたなければならない。つまり、BOM (バイトオーダーマーク) を認識するだけでは十分ではない。&lt;/p&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2295r6.pdf&#34; target=&#34;_blank&#34;&gt;P2295R6 Support for UTF-8 as a portable source file encoding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>#warningのサポートを追加 [P2437R1] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp23/warning.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp23/warning.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp23/warning.md b/lang/cpp23/warning.md
index fdc8f98fa..9c7746394 100644
--- a/lang/cpp23/warning.md
+++ b/lang/cpp23/warning.md
@@ -30,7 +30,7 @@ C++23では、プリプロセッサ命令として、特定のコードに到達
 
 `#error`は到達時にプログラムが不適格になると規定されるが、`#warning`では不適格にならない。
 
-警告メッセージの扱いは実装定義。
+警告メッセージの扱いは処理系定義。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>文字列リテラルの文字エンコーディング失敗を不適格とする [P1854R4] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/making_non-encodable_string_literals_ill-formed.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp26/making_non-encodable_string_literals_ill-formed.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/making_non-encodable_string_literals_ill-formed.md b/lang/cpp26/making_non-encodable_string_literals_ill-formed.md
index 629db80db..a15fe201c 100644
--- a/lang/cpp26/making_non-encodable_string_literals_ill-formed.md
+++ b/lang/cpp26/making_non-encodable_string_literals_ill-formed.md
@@ -18,12 +18,12 @@ wchar_t b = L&amp;#39;ab&amp;#39;; // C++20:OK, C++23:NG マルチキャラクタリテラル
 wchar_t c = L&amp;#39;é&amp;#39;;  // C++20:OK, C++23:NG \u0065\u0301
 ```
 
-C++26ではさらに、文字列リテラルとしてエンコーディングできない文字の扱いが実装定義でコンパイラーに任されていたものを、不適格になるよう仕様変更する。
+C++26ではさらに、文字列リテラルとしてエンコーディングできない文字の扱いが処理系定義でコンパイラーに任されていたものを、不適格になるよう仕様変更する。
 
-また、マルチ文字リテラル (ひとつの文字リテラルに4文字まで入れられて値が実装定義なもの。例として`&amp;#39;intl&amp;#39;`) については、単一のコードユニットにエンコードされるもののみ許可される。
+また、マルチ文字リテラル (ひとつの文字リテラルに4文字まで入れられて値が処理系定義なもの。例として`&amp;#39;intl&amp;#39;`) については、単一のコードユニットにエンコードされるもののみ許可される。
 
 ```cpp
-char c = &amp;#39;é&amp;#39;; // C++23:実装定義, C++26:NG グレイブアクセントをつけると複数のコードユニットになる
+char c = &amp;#39;é&amp;#39;; // C++23:処理系定義, C++26:NG グレイブアクセントをつけると複数のコードユニットになる
 ```
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>属性の無視性を見直し [P2552R3] -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/lang/cpp26/on_the_ignorability_of_standard_attributes.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:lang/cpp26/on_the_ignorability_of_standard_attributes.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/lang/cpp26/on_the_ignorability_of_standard_attributes.md b/lang/cpp26/on_the_ignorability_of_standard_attributes.md
index c522b04b7..93bee34fd 100644
--- a/lang/cpp26/on_the_ignorability_of_standard_attributes.md
+++ b/lang/cpp26/on_the_ignorability_of_standard_attributes.md
@@ -12,7 +12,7 @@
 ## 概要
 C++20時点で、不明な属性を無視する仕様は以下のようになっていた。
 
-「この規格書で規定されていない属性の動作は実装定義である。実装が認識できない属性はすべて無視される。」
+「この規格書で規定されていない属性の動作は処理系定義である。実装が認識できない属性はすべて無視される。」
 
 この仕様は、規格外の属性を無視するものなのか、規格内の属性も無視してよい意図なのか、という点であいまいだった。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>array -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/array/array.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/array/array.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/array/array.md b/reference/array/array.md
index e95c837ed..4116ff382 100644
--- a/reference/array/array.md
+++ b/reference/array/array.md
@@ -79,8 +79,8 @@ namespace std {
 |--------------------------|------------------------------------------------------|-------|
 | `reference`              | 要素の参照型 `T&amp;amp;` | C++11 |
 | `const_reference`        | 読取り専用の要素の参照型 `const T&amp;amp;` | C++11 |
-| `iterator`               | ランダムアクセスイテレータ (実装定義) | C++11 |
-| `const_iterator`         | 読取り専用のランダムアクセスイテレータ (実装定義) | C++11 |
+| `iterator`               | ランダムアクセスイテレータ (処理系定義) | C++11 |
+| `const_iterator`         | 読取り専用のランダムアクセスイテレータ (処理系定義) | C++11 |
 | `reverse_iterator`       | 逆イテレータ [`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;iterator&amp;gt;` | C++11 |
 | `const_reverse_iterator` | 読み取り専用の逆イテレータ [`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;const_iterator&amp;gt;` | C++11 |
 | `size_type`              | 符号なし整数型 [`size_t`](/reference/cstddef/size_t.md) | C++11 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cfenv -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cfenv.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cfenv.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;cfenv&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;cfenv&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt;ヘッダでは、浮動小数点環境にアクセスするための機能が定義される。&lt;/p&gt;
&lt;p&gt;このヘッダは、IEC 60559 (IEEE 754)で定義される浮動小数点例外の状態フラグを管理することを目的として設計されている。「浮動小数点例外の状態フラグ」は、浮動小数点例外の発生によって設定されるシステム変数である。&lt;/p&gt;
&lt;p&gt;浮動小数点環境はスレッドローカル記憶域を持ち、その初期状態は、スレッドを作成したときの浮動小数点環境の状態が設定される。&lt;/p&gt;
&lt;p&gt;プログラム起動時、浮動小数点環境は以下のように初期化される :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浮動小数点例外の全ての状態がクリアされる&lt;/li&gt;
&lt;li&gt;浮動小数点数の丸めモードは「最も近い値への丸め (&lt;code&gt;&lt;a href=&#34;cfenv/fe_tonearest.html&#34;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;)」となる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;浮動小数点環境&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fenv_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点環境の状態を表す型 (type-alias)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fegetenv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;現在の浮動小数点環境を取得する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fesetenv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点環境を設定する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;feholdexcept&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;現在の浮動小数点環境を保存する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;feupdateenv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;現在発生している浮動小数点例外を保存する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;浮動小数点環境マクロ&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FE_DFL_ENV&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトの浮動小数点環境 (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;浮動小数点例外&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fexcept_t.html&#34;&gt;fexcept_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点例外の状態フラグを表す整数型 (type-alias)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/feclearexcept.html&#34;&gt;feclearexcept&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された浮動小数点例外をクリアする (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fegetexceptflag.html&#34;&gt;fegetexceptflag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点例外の現在の状態を、処理系定義の表現で取得する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fesetexceptflag.html&#34;&gt;fesetexceptflag&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点例外を発生させずに、浮動小数点例外の状態を設定する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/feraiseexcept.html&#34;&gt;feraiseexcept&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された浮動小数点例外を発生させる (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fetestexcept.html&#34;&gt;fetestexcept&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された浮動小数点例外が設定されるかを判定する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;浮動小数点例外マクロ&lt;/h3&gt;
&lt;p&gt;以下のマクロは、浮動小数点例外の状態を表すビット値である。これらのマクロは、AND (&lt;code&gt;&amp;amp;&lt;/code&gt;) や OR (&lt;code&gt;|&lt;/code&gt;)を使用して、複数のマクロを組み合わせて使用できる。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_all_except.html&#34;&gt;FE_ALL_EXCEPT&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全ての浮動小数点例外 (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_divbyzero.html&#34;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ゼロ除算 (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_inexact.html&#34;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不正確な結果 (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_invalid.html&#34;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不正な演算 (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_overflow.html&#34;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;オーバーフロー (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_underflow.html&#34;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;アンダーフロー (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;浮動小数点丸め&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fegetround.html&#34;&gt;fegetround&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;現在の丸め方式を取得する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fesetround.html&#34;&gt;fesetround&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;丸め方式を設定する (function)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;浮動小数点丸めマクロ&lt;/h3&gt;
&lt;p&gt;以下のマクロは、浮動小数点の丸めがどのような方式で行われるかを表す。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_downward.html&#34;&gt;FE_DOWNWARD&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;負の無限大方向への丸め (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_tonearest.html&#34;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最も近い値への丸め (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_towardzero.html&#34;&gt;FE_TOWARDZERO&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ゼロ方向への丸め (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;cfenv/fe_upward.html&#34;&gt;FE_UPWARD&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正の無限大方向への丸め (macro)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: ?&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: ?&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#icc&#34;&gt;ICC&lt;/a&gt;: ?&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: 2013 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;, 2015 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;cmath.html&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fegetexceptflag -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cfenv/fegetexceptflag.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cfenv/fegetexceptflag.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cfenv/fegetexceptflag.md b/reference/cfenv/fegetexceptflag.md
index 1f09411ab..bd71d92b6 100644
--- a/reference/cfenv/fegetexceptflag.md
+++ b/reference/cfenv/fegetexceptflag.md
@@ -12,17 +12,17 @@ namespace std {
 * fexcept_t[link fexcept_t.md]
 
 ## 概要
-浮動小数点例外の現在の状態を、実装定義の表現で取得する。
+浮動小数点例外の現在の状態を、処理系定義の表現で取得する。
 
-この関数は、現在発生している浮動小数点例外のうち、指定された例外の集合のみを抽出して、実装定義の表現に変換して返す。
+この関数は、現在発生している浮動小数点例外のうち、指定された例外の集合のみを抽出して、処理系定義の表現に変換して返す。
 
 
 ## 効果
-ビット演算のORで複数指定された浮動小数点例外の種類`excepts`の例外発生状態を、実装定義の表現に変換して`flagp`に書き込んで返す。
+ビット演算のORで複数指定された浮動小数点例外の種類`excepts`の例外発生状態を、処理系定義の表現に変換して`flagp`に書き込んで返す。
 
 
 ## 戻り値
-実装定義の表現への変換および書き込みに成功したら`0`、そうでなければ`0`以外の値を返す。
+処理系定義の表現への変換および書き込みに成功したら`0`、そうでなければ`0`以外の値を返す。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>feraiseexcept -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cfenv/feraiseexcept.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cfenv/feraiseexcept.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cfenv/feraiseexcept.md b/reference/cfenv/feraiseexcept.md
index 73881729f..edeac0f0a 100644
--- a/reference/cfenv/feraiseexcept.md
+++ b/reference/cfenv/feraiseexcept.md
@@ -17,7 +17,7 @@ namespace std {
 ## 効果
 パラメータ`excepts`で指定された浮動小数点例外を発生させる。`excepts`には、ビットORを使用して複数の浮動小数点例外を指定できる。この効果は、算術演算によって発生する浮動小数点例外と同様。発生する例外の順序は未規定。
 
-[`FE_OVERFLOW`](fe_overflow.md)もしくは[`FE_UNDERFLOW`](fe_underflow.md)が指定されたときに、追加で[`FE_INEXACT`](fe_inexact.md)も発生させるかは実装定義。
+[`FE_OVERFLOW`](fe_overflow.md)もしくは[`FE_UNDERFLOW`](fe_underflow.md)が指定されたときに、追加で[`FE_INEXACT`](fe_inexact.md)も発生させるかは処理系定義。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;&lt; -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/chrono/duration/op_ostream.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/chrono/duration/op_ostream.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/duration/op_ostream.md b/reference/chrono/duration/op_ostream.md
index a6922b9fc..981b5b079 100644
--- a/reference/chrono/duration/op_ostream.md
+++ b/reference/chrono/duration/op_ostream.md
@@ -48,7 +48,7 @@ return os &amp;lt;&amp;lt; s.str();
 | [`femto`](/reference/ratio/si_prefix.md)      | `&amp;#34;fs&amp;#34;` |
 | [`pico`](/reference/ratio/si_prefix.md)       | `&amp;#34;ps&amp;#34;` |
 | [`nano`](/reference/ratio/si_prefix.md)       | `&amp;#34;ns&amp;#34;` |
-| [`micro`](/reference/ratio/si_prefix.md)      | `&amp;#34;µs&amp;#34;` (`&amp;#34;\u00b5\u0073&amp;#34;`) もしくは`&amp;#34;us&amp;#34;`が実装定義で選択される |
+| [`micro`](/reference/ratio/si_prefix.md)      | `&amp;#34;µs&amp;#34;` (`&amp;#34;\u00b5\u0073&amp;#34;`) もしくは`&amp;#34;us&amp;#34;`が処理系定義で選択される |
 | [`milli`](/reference/ratio/si_prefix.md)      | `&amp;#34;ms&amp;#34;` |
 | [`centi`](/reference/ratio/si_prefix.md)      | `&amp;#34;cs&amp;#34;` |
 | [`deci`](/reference/ratio/si_prefix.md)       | `&amp;#34;ds&amp;#34;` |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>file_clock -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/chrono/file_clock.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/chrono/file_clock.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/file_clock.md b/reference/chrono/file_clock.md
index 5ea084da9..eb7c705a1 100644
--- a/reference/chrono/file_clock.md
+++ b/reference/chrono/file_clock.md
@@ -104,5 +104,5 @@ int main()
 
 ## 参照
 - [`file_clock` breaks ABI for C++17 implementations](https://wg21.cmeerw.net/lwg/issue3145)
-    - `file_clock`は当初、独立したクラスとして定義することを予定していたが、C++17のファイルシステムライブラリで定義される[`file_time_type`](/reference/filesystem/file_time_type.md)のABI互換性を破壊してしまうことがわかったため、実装定義されるクロックの別名として`file_clock`が定義されることになった
+    - `file_clock`は当初、独立したクラスとして定義することを予定していたが、C++17のファイルシステムライブラリで定義される[`file_time_type`](/reference/filesystem/file_time_type.md)のABI互換性を破壊してしまうことがわかったため、処理系定義されるクロックの別名として`file_clock`が定義されることになった
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>file_time -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/chrono/file_time.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/chrono/file_time.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/file_time.md b/reference/chrono/file_time.md
index 78f642128..0e87781fb 100644
--- a/reference/chrono/file_time.md
+++ b/reference/chrono/file_time.md
@@ -62,7 +62,7 @@ namespace std {
 
 
 ## 備考
-- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`file_clock::time_point`がもつ時間間隔の単位は未規定 (実装定義) であるため、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
+- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`file_clock::time_point`がもつ時間間隔の単位は未規定 (処理系定義) であるため、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
 - (4) :
     - `%Z` (タイムゾーンの略称) が指定された場合、`STATICALLY-WIDEN&amp;lt;charT&amp;gt;(&amp;#34;UTC&amp;#34;)`で置き換えられる
     - `%z`もしくはその改良コマンドが指定された場合、`0`[`min`](duration/op_min.md)が使用される
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gps_time -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/chrono/gps_time.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/chrono/gps_time.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/gps_time.md b/reference/chrono/gps_time.md
index 4d765cffe..f0d041231 100644
--- a/reference/chrono/gps_time.md
+++ b/reference/chrono/gps_time.md
@@ -63,7 +63,7 @@ GPS時間の一点を指す[`time_point`](time_point.md)に対する別名。
 
 
 ## 備考
-- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`gps_clock::time_point`がもつ時間間隔の単位は未規定 (実装定義) であるため、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
+- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`gps_clock::time_point`がもつ時間間隔の単位は未規定 (処理系定義) であるため、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
 - (5) :
     - `%Z` (タイムゾーンの略称) が指定された場合、`STATICALLY-WIDEN&amp;lt;charT&amp;gt;(&amp;#34;GPS&amp;#34;)`で置き換えられる
     - `%z`もしくはその改良コマンドが指定された場合、`0`[`min`](duration/op_min.md)が使用される
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>local_time -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/chrono/local_time.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/chrono/local_time.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/local_time.md b/reference/chrono/local_time.md
index 3a6afb6ad..e4d589251 100644
--- a/reference/chrono/local_time.md
+++ b/reference/chrono/local_time.md
@@ -68,7 +68,7 @@ namespace std {
 
 
 ## 備考
-- (2) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`local_time`がもつ時間間隔の単位は未規定 (実装定義) であり、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
+- (2) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`local_time`がもつ時間間隔の単位は未規定 (処理系定義) であり、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
 - [`year`](year.md)クラスの制限により、年の値としては`[-32767, 32767]`の範囲までしか入出力できないことに注意 (その範囲外は未規定の値となる)
 - (5) : 出力ストリームの演算子は、ローカルのタイムゾーンへの変換を行わない。そのため、システム時間から変換したローカル時間をそのまま出力すると、デフォルトではUTCタイムゾーンの日時が出力される。日本のタイムゾーンで出力したい場合は、[`zoned_time`](zoned_time.md)クラスを介して出力するか、9時間を加算して出力すること
 - (7) : `%Z` (タイムゾーンの略称), `%z` (UTCタイムゾーンからのオフセット時間) もしくはその改良コマンドが指定された場合、[`std::format_error`](/reference/format/format_error.md)例外が送出される
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sys_time -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/chrono/sys_time.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/chrono/sys_time.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/sys_time.md b/reference/chrono/sys_time.md
index 002c44c81..be4f3f30c 100644
--- a/reference/chrono/sys_time.md
+++ b/reference/chrono/sys_time.md
@@ -86,7 +86,7 @@ namespace std {
 
 
 ## 備考
-- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`system_clock::time_point`がもつ時間間隔の単位は未規定 (実装定義) であり、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
+- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`system_clock::time_point`がもつ時間間隔の単位は未規定 (処理系定義) であり、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
 - [`year`](year.md)クラスの制限により、年の値としては`[-32767, 32767]`の範囲までしか入出力できないことに注意 (その範囲外は未規定の値となる)
 - (4), (5) : 出力ストリームの演算子は、ローカルのタイムゾーンへの変換を行わない。そのため、システム時間をそのまま出力すると、デフォルトではUTCタイムゾーンの日時が出力される。日本のタイムゾーンで出力したい場合は、[`zoned_time`](zoned_time.md)クラスを介して出力するか、9時間を加算して出力すること
 - (7) :
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>tai_time -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/chrono/tai_time.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/chrono/tai_time.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/tai_time.md b/reference/chrono/tai_time.md
index edb71db77..de6aea78b 100644
--- a/reference/chrono/tai_time.md
+++ b/reference/chrono/tai_time.md
@@ -63,7 +63,7 @@ TAI時間の一点を指す[`time_point`](time_point.md)に対する別名。
 
 
 ## 備考
-- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`tai_clock::time_point`がもつ時間間隔の単位は未規定 (実装定義) であるため、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
+- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`tai_clock::time_point`がもつ時間間隔の単位は未規定 (処理系定義) であるため、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
 - (5) :
     - `%Z` (タイムゾーンの略称) が指定された場合、`STATICALLY-WIDEN&amp;lt;charT&amp;gt;(&amp;#34;TAI&amp;#34;)`で置き換えられる
     - `%z`もしくはその改良コマンドが指定された場合、`0`[`min`](duration/op_min.md)が使用される
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>utc_time -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/chrono/utc_time.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/chrono/utc_time.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/chrono/utc_time.md b/reference/chrono/utc_time.md
index ac5a5abec..8b486ee59 100644
--- a/reference/chrono/utc_time.md
+++ b/reference/chrono/utc_time.md
@@ -63,7 +63,7 @@ UTC時間の一点を指す[`time_point`](time_point.md)に対する別名。
 
 
 ## 備考
-- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`utc_clock::time_point`がもつ時間間隔の単位は未規定 (実装定義) であるため、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
+- (1) : このバージョンは、関数テンプレートで任意の時間間隔単位の`time_point`を受け取るために使用できる。`utc_clock::time_point`がもつ時間間隔の単位は未規定 (処理系定義) であるため、特定の単位に決めることができないため、時間間隔の型のみをパラメータ化して関数テンプレートで受け取ると便利である
 - (5) :
     - `%Z` (タイムゾーンの略称) が指定された場合、`STATICALLY-WIDEN&amp;lt;charT&amp;gt;(&amp;#34;UTC&amp;#34;)`で置き換えられる
     - `%z`もしくはその改良コマンドが指定された場合、`0`[`min`](duration/op_min.md)が使用される
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assoc_laguerre -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/assoc_laguerre.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/assoc_laguerre.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/assoc_laguerre.md b/reference/cmath/assoc_laguerre.md
index 59f2e3d2f..86032f061 100644
--- a/reference/cmath/assoc_laguerre.md
+++ b/reference/cmath/assoc_laguerre.md
@@ -57,7 +57,7 @@ $$
 
 
 ## 備考
-- `n &amp;gt;= 128 || m &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `n &amp;gt;= 128 || m &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>assoc_legendre -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/assoc_legendre.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/assoc_legendre.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/assoc_legendre.md b/reference/cmath/assoc_legendre.md
index 41ec51eb7..f7aad9985 100644
--- a/reference/cmath/assoc_legendre.md
+++ b/reference/cmath/assoc_legendre.md
@@ -56,7 +56,7 @@ $$
 
 
 ## 備考
-- `l &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `l &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 ### 負の m の対応
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cyl_bessel_i -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cyl_bessel_i.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/cyl_bessel_i.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cyl_bessel_i.md b/reference/cmath/cyl_bessel_i.md
index 6d66d9225..9c3ceb909 100644
--- a/reference/cmath/cyl_bessel_i.md
+++ b/reference/cmath/cyl_bessel_i.md
@@ -53,7 +53,7 @@ $J$ は第1種ベッセル関数 ([`cyl_bessel_j`](cyl_bessel_j.md)) である
 
 
 ## 備考
-- `nu &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `nu &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cyl_bessel_j -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cyl_bessel_j.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/cyl_bessel_j.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cyl_bessel_j.md b/reference/cmath/cyl_bessel_j.md
index 19c4bf196..3d6cdf53c 100644
--- a/reference/cmath/cyl_bessel_j.md
+++ b/reference/cmath/cyl_bessel_j.md
@@ -52,7 +52,7 @@ $$
 
 
 ## 備考
-- `nu &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `nu &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cyl_bessel_k -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cyl_bessel_k.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/cyl_bessel_k.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cyl_bessel_k.md b/reference/cmath/cyl_bessel_k.md
index 85a751bf1..f5a29cd1b 100644
--- a/reference/cmath/cyl_bessel_k.md
+++ b/reference/cmath/cyl_bessel_k.md
@@ -58,7 +58,7 @@ $I$, $J$, $N$ はそれぞれ
 
 
 ## 備考
-- `nu &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `nu &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cyl_neumann -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/cyl_neumann.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/cyl_neumann.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/cyl_neumann.md b/reference/cmath/cyl_neumann.md
index cd072714d..d88ff2584 100644
--- a/reference/cmath/cyl_neumann.md
+++ b/reference/cmath/cyl_neumann.md
@@ -53,7 +53,7 @@ $J$ は第1種ベッセル関数 ([`cyl_bessel_j`](cyl_bessel_j.md)) である
 
 
 ## 備考
-- `nu &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `nu &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>fmod -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/fmod.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/fmod.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/fmod.md b/reference/cmath/fmod.md
index b74689fa3..dc937e0aa 100644
--- a/reference/cmath/fmod.md
+++ b/reference/cmath/fmod.md
@@ -53,7 +53,7 @@ namespace std {
 
 - この関数は、ある整数値を`n`として、`x - ny`を戻り値として返す。
 - `y`が非ゼロである場合、`x`と同じ符号の、`y`より小さい値を返す。
-- `y`がゼロである場合、定義域エラーを発生させるかゼロを返すかは、実装定義となる。
+- `y`がゼロである場合、定義域エラーを発生させるかゼロを返すかは、処理系定義となる。
 
 定義域エラーが発生した際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>hermite -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/hermite.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/hermite.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/hermite.md b/reference/cmath/hermite.md
index 0d00936a1..6f2f7df14 100644
--- a/reference/cmath/hermite.md
+++ b/reference/cmath/hermite.md
@@ -48,7 +48,7 @@ $$ H_n(x) = (-1)^n \exp(x^2) \frac{\mathrm{d}^n}{\mathrm{d}x^n} \exp(-x^2) $$
 
 
 ## 備考
-- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>laguerre -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/laguerre.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/laguerre.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/laguerre.md b/reference/cmath/laguerre.md
index 50494f20b..1da23eefa 100644
--- a/reference/cmath/laguerre.md
+++ b/reference/cmath/laguerre.md
@@ -48,7 +48,7 @@ $$ L_n(x) = \frac{e^x}{n!} \frac{\mathrm{d}^n}{\mathrm{d}x^n} (x^n e^{-x}) \quad
 
 
 ## 備考
-- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>legendre -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/legendre.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/legendre.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/legendre.md b/reference/cmath/legendre.md
index 9c9e54241..73234c4d1 100644
--- a/reference/cmath/legendre.md
+++ b/reference/cmath/legendre.md
@@ -48,7 +48,7 @@ $$ P_l(x) = \frac{1}{2^l l!} \frac{\mathrm{d}^l}{\mathrm{d}x^l} (x^2 - 1)^l \qua
 
 
 ## 備考
-- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remainder -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/remainder.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/remainder.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/remainder.md b/reference/cmath/remainder.md
index 4d4a6e1c4..7a4b1f628 100644
--- a/reference/cmath/remainder.md
+++ b/reference/cmath/remainder.md
@@ -52,7 +52,7 @@ namespace std {
 ## 戻り値
 IEC 60559で要求された`x REM y`を計算して返す。
 
-`y`がゼロである場合、定義域エラーを発生させるかゼロを返すかは、実装定義となる。定義域エラーが発生した際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
+`y`がゼロである場合、定義域エラーを発生させるかゼロを返すかは、処理系定義となる。定義域エラーが発生した際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>remquo -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/remquo.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/remquo.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/remquo.md b/reference/cmath/remquo.md
index 40c30b2ec..2b6aa0d75 100644
--- a/reference/cmath/remquo.md
+++ b/reference/cmath/remquo.md
@@ -73,7 +73,7 @@ namespace std {
 - `quo`が指す値は、`x/y`で得られる商と下位数ビットが等しく、`x/y`で得られた符号と同じ符号を持つ。
     - 商と等しくなる有効なビット数nは、少なくとも3以上の処理系定義の値とされる。
 
-`y`がゼロである場合、`quo`が指す値は未規定となる。またその際、定義域エラーを発生させるかゼロを返すかは、実装定義となる。定義域エラーが発生した際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
+`y`がゼロである場合、`quo`が指す値は未規定となる。またその際、定義域エラーを発生させるかゼロを返すかは、処理系定義となる。定義域エラーが発生した際の挙動については、[`&amp;lt;cmath&amp;gt;`](../cmath.md) を参照。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sph_bessel -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sph_bessel.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/sph_bessel.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sph_bessel.md b/reference/cmath/sph_bessel.md
index 4b9e4ee78..b897af17d 100644
--- a/reference/cmath/sph_bessel.md
+++ b/reference/cmath/sph_bessel.md
@@ -52,7 +52,7 @@ $J$ は第1種ベッセル関数 ([`cyl_bessel_j`](cyl_bessel_j.md))。
 
 
 ## 備考
-- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sph_legendre -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sph_legendre.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/sph_legendre.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sph_legendre.md b/reference/cmath/sph_legendre.md
index daa2b669b..887dce984 100644
--- a/reference/cmath/sph_legendre.md
+++ b/reference/cmath/sph_legendre.md
@@ -57,7 +57,7 @@ $$
 $P_l^m$ はルジャンドル陪関数 ([`assoc_legendre`](assoc_legendre.md)) である。
 
 ## 備考
-- `l &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `l &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 ### 球面調和関数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>sph_neumann -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cmath/sph_neumann.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cmath/sph_neumann.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cmath/sph_neumann.md b/reference/cmath/sph_neumann.md
index beb75e7fa..4c7d68971 100644
--- a/reference/cmath/sph_neumann.md
+++ b/reference/cmath/sph_neumann.md
@@ -52,7 +52,7 @@ $N$ は第2種ベッセル関数 ([`cyl_neumann`](cyl_neumann.md))。
 
 
 ## 備考
-- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は実装定義である
+- `n &amp;gt;= 128` の場合、この関数の呼び出しの効果は処理系定義である
 - (1) : C++23では、拡張浮動小数点数型を含む浮動小数点数型へのオーバーロードとして定義された
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/compare.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/compare.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;compare&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;compare&lt;/span&gt;&lt;span class=&#34;cpp cpp20&#34; title=&#34;C++20で追加&#34;&gt;(C++20)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;compare&amp;gt;&lt;/code&gt;ヘッダでは三方比較演算子&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;の戻り値型である比較カテゴリ型、及び一貫比較に関連するコンセプトや関数等を提供する。&lt;/p&gt;
&lt;p&gt;比較カテゴリ型を返す&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;を利用する際は本ヘッダのインクルードは必須である。&lt;/p&gt;
&lt;p&gt;本ヘッダはフリースタンディング環境でも提供される。&lt;/p&gt;
&lt;h2&gt;代入可能性（&lt;em&gt;substitutability&lt;/em&gt;）&lt;/h2&gt;
&lt;p&gt;代入可能性とは、&lt;code&gt;a == b&lt;/code&gt;ならば&lt;code&gt;f(a) == f(b)&lt;/code&gt;となる性質の事である。なお、ここでの&lt;code&gt;f()&lt;/code&gt;は内部状態や副作用を持たず入力のアクセス可能な要素のみによって出力が決まる関数で、&lt;code&gt;pure&lt;/code&gt;な関数と呼ばれるものである。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strong_ordering&lt;/code&gt;を返す&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;における同値比較がこの性質を満たしていることを表明する。このカテゴリを返す&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;を実装する際はこれらの性質を満たすように実装する必要がある。&lt;/p&gt;
&lt;p&gt;数学の言葉ではこの性質は代入原理（&lt;em&gt;Substitution property&lt;/em&gt;）と呼ばれ、これを満たす同値関係のことを特に相当関係と呼ぶ。&lt;br /&gt;
また、相当関係による同値類（ある集合上で&lt;code&gt;a == b&lt;/code&gt;となる要素を集めて出来る集合）を考れば、それら同値類のどれを取ってもその要素はただ1つだけとなる。その意味から、相当関係は最も細かい同値関係とも呼ばれる。&lt;/p&gt;
&lt;h2&gt;比較カテゴリ型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/partial_ordering.html&#34;&gt;partial_ordering&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;半順序関係を表す比較カテゴリ型&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/weak_ordering.html&#34;&gt;weak_ordering&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;弱順序関係を表す比較カテゴリ型&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/strong_ordering.html&#34;&gt;strong_ordering&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全順序関係を表す比較カテゴリ型&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;三方比較の結果型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/common_comparison_category.html&#34;&gt;common_comparison_category&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された全ての型の共通比較カテゴリ型を求める&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/compare_three_way_result.html&#34;&gt;compare_three_way_result&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された型の間での&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;による比較結果の型を求める&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;コンセプト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/three_way_comparable.html&#34;&gt;three_way_comparable&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された型が&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;による比較が可能であり、結果が指定した比較カテゴリ型に変換可能である&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/three_way_comparable.html&#34;&gt;three_way_comparable_with&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された型の間で&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;による比較が可能であり、結果が指定した比較カテゴリ型に変換可能である&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;名前付きの比較関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/named_comparison_functions.html&#34;&gt;is_eq&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt;の比較結果が&lt;code&gt;a == b&lt;/code&gt;であるかを取得する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/named_comparison_functions.html&#34;&gt;is_neq&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt;の比較結果が&lt;code&gt;a != b&lt;/code&gt;であるかを取得する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/named_comparison_functions.html&#34;&gt;is_lt&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt;の比較結果が&lt;code&gt;a &amp;lt; b&lt;/code&gt;であるかを取得する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/named_comparison_functions.html&#34;&gt;is_lteq&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt;の比較結果が&lt;code&gt;a &amp;lt;= b&lt;/code&gt;であるかを取得する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/named_comparison_functions.html&#34;&gt;is_gt&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt;の比較結果が&lt;code&gt;a &amp;gt; b&lt;/code&gt;であるかを取得する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/named_comparison_functions.html&#34;&gt;is_gteq&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt;の比較結果が&lt;code&gt;a &amp;gt;= b&lt;/code&gt;であるかを取得する&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;比較関数オブジェクト&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/compare_three_way.html&#34;&gt;compare_three_way&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ポインタ比較時のみ処理系定義の狭義全順序によって、その他の場合はデフォルトの三方比較を行う&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/strong_order.html&#34;&gt;strong_order&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全順序による三方比較を行う（カスタマイゼーションポイントオブジェクト）&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/weak_order.html&#34;&gt;weak_order&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;弱順序による三方比較を行う（カスタマイゼーションポイントオブジェクト）&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/partial_order.html&#34;&gt;partial_order&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;半順序による三方比較を行う（カスタマイゼーションポイントオブジェクト）&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/compare_strong_order_fallback.html&#34;&gt;compare_strong_order_fallback&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;が無い場合でも&lt;code&gt;&amp;lt; ==&lt;/code&gt;を用いて全順序による三方比較を行う（カスタマイゼーションポイントオブジェクト）&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/compare_weak_order_fallback.html&#34;&gt;compare_weak_order_fallback&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;が無い場合でも&lt;code&gt;&amp;lt; ==&lt;/code&gt;を用いて弱順序による三方比較を行う（カスタマイゼーションポイントオブジェクト）&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;compare/compare_partial_order_fallback.html&#34;&gt;compare_partial_order_fallback&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;が無い場合でも&lt;code&gt;&amp;lt; ==&lt;/code&gt;を用いて半順序による三方比較を行う（カスタマイゼーションポイントオブジェクト）&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++20&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;処理系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#clang&#34;&gt;Clang&lt;/a&gt;: 8.0 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#gcc&#34;&gt;GCC&lt;/a&gt;: 10.1 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../implementation.html#visual_cpp&#34;&gt;Visual C++&lt;/a&gt;: 2019 &lt;span aria-label=&#34;検証済&#34; role=&#34;img&#34; title=&#34;検証済&#34;&gt;✅&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../lang/cpp20/consistent_comparison.html&#34;&gt;C++20 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;/&lt;code&gt;==&lt;/code&gt;による比較演算子の自動定義&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wg21.link/p0768&#34; target=&#34;_blank&#34;&gt;P0768R1 Library support for the spaceship (comparison) operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wg21.link/p1614&#34; target=&#34;_blank&#34;&gt;P1614R2 The Mothership has Landed (Adding &amp;lt;=&amp;gt; to the Library)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1959r0.html&#34; target=&#34;_blank&#34;&gt;P1959R0 Remove &lt;code&gt;std::weak_equality&lt;/code&gt; and &lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1855r0.html&#34; target=&#34;_blank&#34;&gt;P1855R0 Make &lt;code&gt;&amp;lt;compare&amp;gt;&lt;/code&gt; freestanding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>compare_three_way -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/compare/compare_three_way.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/compare/compare_three_way.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/compare/compare_three_way.md b/reference/compare/compare_three_way.md
index 77f2ae909..184c10a8d 100644
--- a/reference/compare/compare_three_way.md
+++ b/reference/compare/compare_three_way.md
@@ -19,7 +19,7 @@ struct compare_three_way {
 ## 概要
 
 `compare_three_way`クラスは、`&amp;lt;=&amp;gt;`による三方比較を行う関数オブジェクトである。  
-特に、ポインタの比較時に実装定義の狭義全順序による比較を行うため、組み込みの`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`演算子での順序付けが未規定の場合でも順序付けを行う事ができる。
+特に、ポインタの比較時に処理系定義の狭義全順序による比較を行うため、組み込みの`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=`演算子での順序付けが未規定の場合でも順序付けを行う事ができる。
 
 
 ## メンバ関数
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/compare/compare_three_way/op_call.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/compare/compare_three_way/op_call.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/compare/compare_three_way/op_call.md b/reference/compare/compare_three_way/op_call.md
index d223cc3e6..84418c619 100644
--- a/reference/compare/compare_three_way/op_call.md
+++ b/reference/compare/compare_three_way/op_call.md
@@ -13,7 +13,7 @@ constexpr auto operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
 
 ## 概要
 
-ポインタ比較時のみ実装定義の狭義全順序による三方比較を行い、それ以外の場合は使用可能な`&amp;lt;=&amp;gt;`による三方比較を行う。
+ポインタ比較時のみ処理系定義の狭義全順序による三方比較を行い、それ以外の場合は使用可能な`&amp;lt;=&amp;gt;`による三方比較を行う。
 
 ## テンプレートパラメータ制約
 
@@ -45,8 +45,8 @@ constexpr auto operator()(T&amp;amp;&amp;amp; t, U&amp;amp;&amp;amp; u) const;
 
 ## 備考
 
-ポインタ比較時の順序付けは、ポインタ型`P`に対する実装定義の狭義全順序の上で行われ、`P`に対する組み込みの比較演算子が持つ半順序関係との一貫性がある。  
-すなわちこの関数オブジェクトによるポインタ値の比較では、組み込みの`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;= == !=`演算子の結果が未規定の場合でも実装定義ではあるが大小もしくは等価性を判定でき、順序が規定されている範囲での順序関係は組み込みの演算子の結果と一致する。
+ポインタ比較時の順序付けは、ポインタ型`P`に対する処理系定義の狭義全順序の上で行われ、`P`に対する組み込みの比較演算子が持つ半順序関係との一貫性がある。  
+すなわちこの関数オブジェクトによるポインタ値の比較では、組み込みの`&amp;lt; &amp;lt;= &amp;gt; &amp;gt;= == !=`演算子の結果が未規定の場合でも処理系定義ではあるが大小もしくは等価性を判定でき、順序が規定されている範囲での順序関係は組み込みの演算子の結果と一致する。
 
 例えば、同じ型の異なる（1つの配列内に含まれていない）オブジェクトに対するポインタ間に何らかの順序を付ける事ができる。  
 ただし、そのような順序付けの結果がコンパイラや実行環境を超えて一致する保証はないので注意が必要である。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>at_quick_exit -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cstdlib/at_quick_exit.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cstdlib/at_quick_exit.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdlib/at_quick_exit.md b/reference/cstdlib/at_quick_exit.md
index b40a96bc6..d5e74effa 100644
--- a/reference/cstdlib/at_quick_exit.md
+++ b/reference/cstdlib/at_quick_exit.md
@@ -28,7 +28,7 @@ namespace std {
 ## 備考
 この関数では、複数の関数を登録できる。
 
-登録できる上限数は実装定義だが、32個以上は登録できることが実装に要求される。
+登録できる上限数は処理系定義だが、32個以上は登録できることが実装に要求される。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>atexit -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/cstdlib/atexit.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/cstdlib/atexit.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/cstdlib/atexit.md b/reference/cstdlib/atexit.md
index cbc3ea2b8..408dbba6b 100644
--- a/reference/cstdlib/atexit.md
+++ b/reference/cstdlib/atexit.md
@@ -35,7 +35,7 @@ namespace std {
 ## 備考
 この関数では、複数の関数を登録できる。
 
-登録できる上限数は実装定義だが、32個以上は登録できることが実装に要求される。
+登録できる上限数は処理系定義だが、32個以上は登録できることが実装に要求される。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>time_t -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/ctime/time_t.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/ctime/time_t.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ctime/time_t.md b/reference/ctime/time_t.md
index bcaf6ab18..96cad70b8 100644
--- a/reference/ctime/time_t.md
+++ b/reference/ctime/time_t.md
@@ -15,11 +15,11 @@ namespace std {
 - C++11 (C99) まで、この型は整数型の別名
 - C++14 (C11) 以降、この型は整数型もしくは浮動小数点数型の別名
 
-この型の分解能と値の範囲は実装定義。
+この型の分解能と値の範囲は処理系定義。
 
 
 ## 備考
-- 値の範囲が実装定義であるため、策定当時の標準ライブラリ実装では32ビット符号付き整数型の別名として定義されていた。しかし32ビットでは秒単位で扱った場合に、西暦2038年1月19日にオーバーフローしてしまうことが判明した。そのため、現在多くの実装では64ビット符号付き整数型の別名として定義される。64ビットで秒単位の場合は西暦3000億年まで扱えるため、オーバーフローの問題は気にしなくてよいだろう
+- 値の範囲が処理系定義であるため、策定当時の標準ライブラリ実装では32ビット符号付き整数型の別名として定義されていた。しかし32ビットでは秒単位で扱った場合に、西暦2038年1月19日にオーバーフローしてしまうことが判明した。そのため、現在多くの実装では64ビット符号付き整数型の別名として定義される。64ビットで秒単位の場合は西暦3000億年まで扱えるため、オーバーフローの問題は気にしなくてよいだろう
 - Cの規格として、`time_t`はreal typeであると定義される。Cでのreal typeは、整数型と浮動小数点型の総称である
     - C++にそのような型の分類はない
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>breakpoint -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/debugging/breakpoint.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/debugging/breakpoint.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/debugging/breakpoint.md b/reference/debugging/breakpoint.md
index eb882cec9..206fb5159 100644
--- a/reference/debugging/breakpoint.md
+++ b/reference/debugging/breakpoint.md
@@ -19,7 +19,7 @@ namespace std {
 
 
 ## 効果
-標準規格としては、この関数の意味論は実装定義である。
+標準規格としては、この関数の意味論は処理系定義である。
 
 実際の動作としては、この関数が呼び出されるとプログラムの実行が一時停止され、以下のいずれかの時点までデバッガに制御が渡される：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is_debugger_present -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/debugging/is_debugger_present.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/debugging/is_debugger_present.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/debugging/is_debugger_present.md b/reference/debugging/is_debugger_present.md
index 098f6e296..3222e0316 100644
--- a/reference/debugging/is_debugger_present.md
+++ b/reference/debugging/is_debugger_present.md
@@ -26,7 +26,7 @@ namespace std {
 
 
 ## デフォルトの振る舞い
-- 実装定義
+- 処理系定義
 
 
 ## 効果
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>what -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/expected/bad_expected_access/what.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/expected/bad_expected_access/what.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/expected/bad_expected_access/what.md b/reference/expected/bad_expected_access/what.md
index dfc030aab..85e659971 100644
--- a/reference/expected/bad_expected_access/what.md
+++ b/reference/expected/bad_expected_access/what.md
@@ -15,7 +15,7 @@ constexpr const char* what() const noexcept override; // (1) C++26
 
 
 ## 戻り値
-エラー理由となる実装定義の文字列
+エラー理由となる処理系定義の文字列
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/copy.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/copy.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/copy.md b/reference/filesystem/copy.md
index fda98b057..129d075ad 100644
--- a/reference/filesystem/copy.md
+++ b/reference/filesystem/copy.md
@@ -52,7 +52,7 @@ namespace std::filesystem {
         * symlink_status[link symlink_status.md]
         * status[link status.md]
 
-    - `f.`[`type()`](file_status/type.md)もしくは`t.`[`type()`](file_status/type.md)が実装定義のファイル種別であった場合、その効果は実装定義となる
+    - `f.`[`type()`](file_status/type.md)もしくは`t.`[`type()`](file_status/type.md)が処理系定義のファイル種別であった場合、その効果は処理系定義となる
     - 以下のいずれかの場合、エラーを報告する。(3)の場合は例外、(4)の場合は`ec`にエラー情報を設定することでエラー報告とする：
         - `!`[`exists`](exists.md)`(f)`
         - [`equivalent`](equivalent.md)`(from, to)`
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>file_size -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/file_size.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/file_size.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/file_size.md b/reference/filesystem/file_size.md
index 7c33ecbb4..9fb81ab47 100644
--- a/reference/filesystem/file_size.md
+++ b/reference/filesystem/file_size.md
@@ -21,7 +21,7 @@ namespace std::filesystem {
 - ファイルが存在しない、もしくはファイルシステムでエラーが発生した場合、 (1) では[`std::filesystem::filesystem_error`](filesystem_error.md)例外を送出し、 (2) では`ec`にエラー情報が設定されて`static_cast&amp;lt;`[`uintmax_t`](/reference/cstdint/uintmax_t.md)`&amp;gt;(-1)`が返る
 - `p`が通常ファイル、もしくは通常ファイルを指すシンボリックリンクである場合、ファイルサイズが返る
     - POSIX環境では[`stat()`](https://web.archive.org/web/20230827123440/https://linuxjm.osdn.jp/html/LDP_man-pages/man2/stat.2.html)関数の`st_size`メンバ変数を使用する
-- `p`がそれ以外のファイル種別である場合は、実装定義の動作をする
+- `p`がそれ以外のファイル種別である場合は、処理系定義の動作をする
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>file_time_type -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/file_time_type.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/file_time_type.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/file_time_type.md b/reference/filesystem/file_time_type.md
index f542e9de8..a29b20dc0 100644
--- a/reference/filesystem/file_time_type.md
+++ b/reference/filesystem/file_time_type.md
@@ -6,7 +6,7 @@
 
 ```cpp
 namespace std::filesystem {
-  using file_time_type = chrono::time_point&amp;lt;実装定義のクロック型&amp;gt;; // (1) C++17
+  using file_time_type = chrono::time_point&amp;lt;処理系定義のクロック型&amp;gt;; // (1) C++17
   using file_time_type = chrono::time_point&amp;lt;chrono::file_clock&amp;gt;;   // (1) C++20
 }
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>file_type -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/file_type.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/file_type.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/file_type.md b/reference/filesystem/file_type.md
index eb4886f6a..c6b54830d 100644
--- a/reference/filesystem/file_type.md
+++ b/reference/filesystem/file_type.md
@@ -40,7 +40,7 @@ namespace std::filesystem {
 | `character` | キャラクタ・スペシャル・ファイル。キャラクタデバイスとも呼ばれる |
 | `fifo`      | FIFOファイルもしくはパイプファイル |
 | `socket`    | ソケットファイル |
-| implementation-defined | OSのファイルシステムがサポートする実装定義のファイル種別 |
+| implementation-defined | OSのファイルシステムがサポートする処理系定義のファイル種別 |
 | `unknown`   | ファイルは存在するが種別を決定できなかった |
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>what -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/filesystem_error/what.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/filesystem_error/what.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/filesystem_error/what.md b/reference/filesystem/filesystem_error/what.md
index 9a5235cd3..94e965a4e 100644
--- a/reference/filesystem/filesystem_error/what.md
+++ b/reference/filesystem/filesystem_error/what.md
@@ -14,7 +14,7 @@ const char* what() const noexcept override;
 
 
 ## 戻り値
-コンストラクタで設定されたエラー理由を含む未規定のフォーマットの実装定義の文字列を返す。
+コンストラクタで設定されたエラー理由を含む未規定のフォーマットの処理系定義の文字列を返す。
 
 実装は、[`system_error`](/reference/system_error/system_error.md)`::what()`で返される文字列とネイティブ形式の`path1`と`path2`を含める必要がある。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>root_directory -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/root_directory.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/path/root_directory.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/root_directory.md b/reference/filesystem/path/root_directory.md
index 5a64996d7..cfc7b68a5 100644
--- a/reference/filesystem/path/root_directory.md
+++ b/reference/filesystem/path/root_directory.md
@@ -12,7 +12,7 @@ path root_directory() const;
 ## 概要
 パスが保持しているルートディレクトリを取得する。
 
-ルートディレクトリは、ルート名に続いて現れる実装定義のディレクトリ区切り文字である。
+ルートディレクトリは、ルート名に続いて現れる処理系定義のディレクトリ区切り文字である。
 
 
 ## 戻り値
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>root_name -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/path/root_name.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/path/root_name.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/path/root_name.md b/reference/filesystem/path/root_name.md
index 9727c59b2..862e900ad 100644
--- a/reference/filesystem/path/root_name.md
+++ b/reference/filesystem/path/root_name.md
@@ -12,7 +12,7 @@ path root_name() const;
 ## 概要
 パスが保持しているルート名を取得する。
 
-ルート名は、パス名解決のための開始位置を表す識別子である。これは、ディレクトリ区切り文字を含まない、OS依存もしくは実装定義の文字列であり、代表的な環境では以下のようになる：
+ルート名は、パス名解決のための開始位置を表す識別子である。これは、ディレクトリ区切り文字を含まない、OS依存もしくは処理系定義の文字列であり、代表的な環境では以下のようになる：
 
 - POSIXベースシステム : 空文字列
 - Windows : `&amp;#34;C:&amp;#34;`のようなディスクドライブを表す文字列
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>status -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/status.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/status.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/status.md b/reference/filesystem/status.md
index cbe8059c5..c32951946 100644
--- a/reference/filesystem/status.md
+++ b/reference/filesystem/status.md
@@ -27,7 +27,7 @@ namespace std::filesystem {
 error_code ec;
 file_status result = status(p, ec);
 if (result.type() == file_type::none)
-    throw filesystem_error(実装定義のメッセージ, p, ec);
+    throw filesystem_error(処理系定義のメッセージ, p, ec);
 
 return result;
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>symlink_status -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/filesystem/symlink_status.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/filesystem/symlink_status.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/filesystem/symlink_status.md b/reference/filesystem/symlink_status.md
index 5514d9e2a..74eadd2e2 100644
--- a/reference/filesystem/symlink_status.md
+++ b/reference/filesystem/symlink_status.md
@@ -27,7 +27,7 @@ namespace std::filesystem {
 error_code ec;
 file_status result = symlink_status(p, ec);
 if (result.type() == file_type::none)
-    throw filesystem_error(実装定義のメッセージ, p, ec);
+    throw filesystem_error(処理系定義のメッセージ, p, ec);
 
 return result;
 ```
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>async -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/future/async.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/future/async.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/async.md b/reference/future/async.md
index ab7eb2f97..aca1a76ff 100644
--- a/reference/future/async.md
+++ b/reference/future/async.md
@@ -65,7 +65,7 @@ namespace std {
 ## 効果
 この関数は、パラメータ`policy`で指定された実行ポリシーの値によって振る舞いを変える。
 
-`policy`を指定しない場合は[`launch::async`](launch.md) `|` [`launch::deferred`](launch.md)となり、どちらの実行ポリシーが選択されるかは実装定義となる。
+`policy`を指定しない場合は[`launch::async`](launch.md) `|` [`launch::deferred`](launch.md)となり、どちらの実行ポリシーが選択されるかは処理系定義となる。
 
 各実行ポリシーの振る舞いは以下のようになる：
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>future_errc -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/future/future_errc.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/future/future_errc.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/future_errc.md b/reference/future/future_errc.md
index 90c2c529e..95b523faa 100644
--- a/reference/future/future_errc.md
+++ b/reference/future/future_errc.md
@@ -49,5 +49,5 @@ future操作に関するエラー値。
 
 ## 参照
 - [LWG2056 - future_errc enums start with value 0 (invalid value for broken_promise)](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2056)
-    - C++11の`future_errc`は、開始値が0だった。[`error_code`](/reference/system_error/error_code.md)クラスの[`operator bool()`](/reference/system_error/error_code/op_bool.md)が0を正常値と見なしてしまうため、C++14では`future_errc`の値を実装定義とした。
+    - C++11の`future_errc`は、開始値が0だった。[`error_code`](/reference/system_error/error_code.md)クラスの[`operator bool()`](/reference/system_error/error_code/op_bool.md)が0を正常値と見なしてしまうため、C++14では`future_errc`の値を処理系定義とした。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>launch -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/future/launch.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/future/launch.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/future/launch.md b/reference/future/launch.md
index f0ea8f0db..c94f4295b 100644
--- a/reference/future/launch.md
+++ b/reference/future/launch.md
@@ -25,7 +25,7 @@ namespace std {
 |--------|------|----------------|
 | `async` | 関数を別スレッドで非同期実行する。値は未規定。 | C++11 |
 | `deferred` | [`future`](future.md)から値を取り出すタイミングまで関数の評価を遅延させる。値は未規定。 | C++11 |
-| 実装定義の列挙値 | 実装による拡張実行ポリシーを許可する | C++11 |
+| 処理系定義の列挙値 | 実装による拡張実行ポリシーを許可する | C++11 |
 
 
 ## バージョン
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>is-integer-like -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/iterator/is_integer_like.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/iterator/is_integer_like.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/is_integer_like.md b/reference/iterator/is_integer_like.md
index afaa39b97..4a16b36a0 100644
--- a/reference/iterator/is_integer_like.md
+++ b/reference/iterator/is_integer_like.md
@@ -19,7 +19,7 @@ namespace std {
 
 これらの説明専用の変数テンプレートは、任意の型`T`が符号付/なし整数型そのものあるいはそれと同様に扱える型である場合に`true`を示すものである。
 
-これは標準ライブラリ内において、イテレータの差分型（`difference_type`）として実装定義の整数型の使用を許可するためにコンセプトの文脈で使用される。
+これは標準ライブラリ内において、イテレータの差分型（`difference_type`）として処理系定義の整数型の使用を許可するためにコンセプトの文脈で使用される。
 
 ## 効果
 
@@ -28,7 +28,7 @@ namespace std {
 
 ## (signed-)integer-class型
 
-*integer-class*型は組み込みの整数型と同じように動作する実装定義のクラス型である。
+*integer-class*型は組み込みの整数型と同じように動作する処理系定義のクラス型である。
 
 *integer-class*型の表現可能な範囲はそれが定義する値の連続集合であり、`0`と`1`を必ず含んでいなければならない。この時、その範囲に負の数が含まれていればその型は*signed-integer-class*型であり、それ以外のものは*unsigned-integer-class*型である。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator++ -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/iterator/istreambuf_iterator/op_increment.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/iterator/istreambuf_iterator/op_increment.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/iterator/istreambuf_iterator/op_increment.md b/reference/iterator/istreambuf_iterator/op_increment.md
index a6db381d0..495cf4795 100644
--- a/reference/iterator/istreambuf_iterator/op_increment.md
+++ b/reference/iterator/istreambuf_iterator/op_increment.md
@@ -21,7 +21,7 @@ proxy operator++(int);
 
 後置インクリメント：
 `sbuf-&amp;gt;sbumpc()`を行い、前の状態を`proxy`オブジェクトとして返す。
-`proxy`クラスは実装定義。
+`proxy`クラスは処理系定義。
 
 ※`sbuf_`は、メンバ変数として保持している`streambuf_type`オブジェクトへのポインタ
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>map -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/map/map.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/map/map.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/map/map.md b/reference/map/map.md
index d72cc475e..c0f167e6c 100644
--- a/reference/map/map.md
+++ b/reference/map/map.md
@@ -142,7 +142,7 @@ namespace std {
 | `reverse_iterator`                      | 逆順双方向イテレータ。`std::`[`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;iterator&amp;gt;`。                                                                                                                                                                                                                                     |                |
 | `const_reverse_iterator`                | 読み取り専用逆順双方向イテレータ。`std::`[`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;const_iterator&amp;gt;`。                                                                                                                                                                                                                   |                |
 | `node_type`                             | [`node_handle`](/reference/node_handle/node_handle.md)クラステンプレートの特殊化。                                                                                                                                                                                                                   | C++17          |
-| `insert_return_type`                    | ノードを挿入した結果を記述するために使用されるクラス型。以下に示す`insert-return-type`テンプレートの特殊化である。ただし、これは説明用のクラスであり、実装定義である。| C++17          |
+| `insert_return_type`                    | ノードを挿入した結果を記述するために使用されるクラス型。以下に示す`insert-return-type`テンプレートの特殊化である。ただし、これは説明用のクラスであり、処理系定義である。| C++17          |
 
 ```cpp
 template &amp;lt;class Iterator, class NodeType&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/memory/shared_ptr/op_constructor.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/memory/shared_ptr/op_constructor.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory/shared_ptr/op_constructor.md b/reference/memory/shared_ptr/op_constructor.md
index c6790ee80..dd7bc8ed3 100644
--- a/reference/memory/shared_ptr/op_constructor.md
+++ b/reference/memory/shared_ptr/op_constructor.md
@@ -135,7 +135,7 @@ shared_ptr(shared_ptr&amp;lt;Y&amp;gt;&amp;amp;&amp;amp; r, element_type* p) noexcept; // (16) C++20
 ## 例外
 - (3), (4), (5), (6) : メモリ確保に失敗した場合、[`bad_alloc`](/reference/new/bad_alloc.md)例外を送出する。例外送出時には`d(p)`を呼び出すことが保証される。
 - (12) : `r.`[`expired()`](/reference/memory/weak_ptr/expired.md) `== true`の場合、[`bad_weak_ptr`](/reference/memory/bad_weak_ptr.md)例外を送出する。
-- (13) : メモリ確保に失敗した場合、[`bad_alloc`](/reference/new/bad_alloc.md)もしくはその他実装定義の例外を送出する。
+- (13) : メモリ確保に失敗した場合、[`bad_alloc`](/reference/new/bad_alloc.md)もしくはその他処理系定義の例外を送出する。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>do_allocate -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/monotonic_buffer_resource/do_allocate.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/memory_resource/monotonic_buffer_resource/do_allocate.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/monotonic_buffer_resource/do_allocate.md b/reference/memory_resource/monotonic_buffer_resource/do_allocate.md
index 53e63c218..2ff2ae710 100644
--- a/reference/memory_resource/monotonic_buffer_resource/do_allocate.md
+++ b/reference/memory_resource/monotonic_buffer_resource/do_allocate.md
@@ -28,7 +28,7 @@ void* do_allocate(std::size_t bytes, std::size_t alignment) override;
 
 内部メモリ領域を補充する場合、[`this-&amp;gt;upstream_resource()`](upstream_resource.md)[`-&amp;gt;allocate(n, m)`](/reference/memory_resource/memory_resource/allocate.md)のように上流メモリリソースから追加のメモリを取得する。  
 次に補充する予定のメモリ領域サイズを`next_buffer_size`という変数に保持しているとすると`n, m`は`n = max(bytes, next_buffer_size)`、`m &amp;gt;= alignment `となる値をそれぞれ用いる。  
-その後、`next_buffer_size`を実装定義の増加分（整数とは限らない）だけ増やす。
+その後、`next_buffer_size`を処理系定義の増加分（整数とは限らない）だけ増やす。
 
 少なくとも`bytes`のメモリを割り当て、`alignment`にアラインする。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/monotonic_buffer_resource/op_constructor.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/memory_resource/monotonic_buffer_resource/op_constructor.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/monotonic_buffer_resource/op_constructor.md b/reference/memory_resource/monotonic_buffer_resource/op_constructor.md
index f9aa78739..f87d330f6 100644
--- a/reference/memory_resource/monotonic_buffer_resource/op_constructor.md
+++ b/reference/memory_resource/monotonic_buffer_resource/op_constructor.md
@@ -51,11 +51,11 @@ monotonic_buffer_resource(const monotonic_buffer_resource&amp;amp;) = delete;
 
 ## 効果
 
-- (1) : `upstream`を上流`memory_resource`として設定し、初期メモリ領域を空（`nullptr`）、次に補充するメモリサイズを実装定義の値に設定
+- (1) : `upstream`を上流`memory_resource`として設定し、初期メモリ領域を空（`nullptr`）、次に補充するメモリサイズを処理系定義の値に設定
 
 - (2) : `upstream`を上流`memory_resource`として設定し、初期メモリ領域を空（`nullptr`）、次に補充するメモリサイズを`initial_size`に設定
 
-- (3) : `upstream`を上流`memory_resource`として設定し、`buffer`を初期メモリ領域、`buffer_size`に実装定義の増加分を足した値（整数とは限らない）を次に補充するメモリサイズに設定
+- (3) : `upstream`を上流`memory_resource`として設定し、`buffer`を初期メモリ領域、`buffer_size`に処理系定義の増加分を足した値（整数とは限らない）を次に補充するメモリサイズに設定
 
 - (4) : [`get_default_resource()`](/reference/memory_resource/get_default_resource.md)から取得した`memory_resource`を(1)に渡し委譲
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>pool_options -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/pool_options.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/memory_resource/pool_options.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/pool_options.md b/reference/memory_resource/pool_options.md
index f4d198d37..10241cf23 100644
--- a/reference/memory_resource/pool_options.md
+++ b/reference/memory_resource/pool_options.md
@@ -23,7 +23,7 @@ namespace std::pmr {
 | `max_blocks_per_chunk` | メモリプールを補充する際に上流`memory_resource`から1度に取得するブロックサイズの最大値。&amp;lt;br/&amp;gt;すなわち、サイズ毎のプール内の1チャンク辺りの最大ブロック数。&amp;lt;br/&amp;gt;各メモリプールを補充する際はチャンク単位で補充されチャンクサイズはそのたびに増加するが、この値よりは大きくならない。 | C++17 |
 | `largest_required_pool_block` | 各メモリプールの最も大きなブロックのサイズ。&amp;lt;br/&amp;gt;この値より大きなメモリの割り当て要求は上流の`memory_resource`から直接割り当てられる。 | C++17 |
 
-両変数共に、設定値が0もしくは実装定義の最大値を上回る場合は実装定義の最大値が利用される。  
+両変数共に、設定値が0もしくは処理系定義の最大値を上回る場合は処理系定義の最大値が利用される。  
 また、それが各[`pool_resource`](pool_resource.md)のデフォルト設定となる。
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>do_allocate -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/pool_resource/do_allocate.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/memory_resource/pool_resource/do_allocate.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/pool_resource/do_allocate.md b/reference/memory_resource/pool_resource/do_allocate.md
index c0151f58f..ff98ef8bf 100644
--- a/reference/memory_resource/pool_resource/do_allocate.md
+++ b/reference/memory_resource/pool_resource/do_allocate.md
@@ -25,7 +25,7 @@ void* do_allocate(std::size_t bytes, std::size_t alignment) override;
 ## 効果
 `bytes`以上で最小のブロックサイズの内部メモリプールからメモリを割り当てる。  
 そのようなブロックサイズのプールが枯渇している場合、上流メモリリソースからプールを補充しメモリ割り当てを行う。  
-プールの補充はチャンク単位で行われ、補充の度にチャンクサイズは増加する。その上限はコンストラクタで渡した[`pool_options::max_blocks_per_chunk`](/reference/memory_resource/pool_options.md)か、実装定義の最大値が設定される。
+プールの補充はチャンク単位で行われ、補充の度にチャンクサイズは増加する。その上限はコンストラクタで渡した[`pool_options::max_blocks_per_chunk`](/reference/memory_resource/pool_options.md)か、処理系定義の最大値が設定される。
 
 また、`bytes`が設定されている最大のブロックサイズを超える場合は上流メモリリソースから直接メモリを割り当てる。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>options -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/memory_resource/pool_resource/options.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/memory_resource/pool_resource/options.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/memory_resource/pool_resource/options.md b/reference/memory_resource/pool_resource/options.md
index e09682910..24f6f1733 100644
--- a/reference/memory_resource/pool_resource/options.md
+++ b/reference/memory_resource/pool_resource/options.md
@@ -17,7 +17,7 @@ pool_options options() const;
 内部のメモリプールを調整している値を保持した[`pool_options`](/reference/memory_resource/pool_options.md)。
 
 返される値はコンストラクタで設定した値と異なる可能性がある。  
-ゼロの値は実装定義のデフォルト値に置き換えられて返され、各サイズ指定は指定していない端数を持つ可能性がある（例えば、2の累乗等）。
+ゼロの値は処理系定義のデフォルト値に置き換えられて返され、各サイズ指定は指定していない端数を持つ可能性がある（例えば、2の累乗等）。
 
 ## 例
 以下では`synchronized_pool_resource`で書いてあるが、`unsynchronized_pool_resource`も同様。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>lcm -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/numeric/lcm.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/numeric/lcm.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/numeric/lcm.md b/reference/numeric/lcm.md
index 5dfbdba6f..e99fe0aee 100644
--- a/reference/numeric/lcm.md
+++ b/reference/numeric/lcm.md
@@ -70,7 +70,7 @@ int main() {
   std::uint16_t m = 20000;
   std::uint16_t n = 40000;
 
-  // 標準std::lcm()の動作は実装定義
+  // 標準std::lcm()の動作は処理系定義
   std::cout &amp;lt;&amp;lt; &amp;#34;std::lcm(&amp;#34; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;#34;, &amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#34;)     &amp;#34; &amp;lt;&amp;lt; std::lcm(m, n) &amp;lt;&amp;lt; std::endl;
 
   // 公式通りのオーバーフローしやすい最小公倍数の実装
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator&lt;&lt; -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/ostream/basic_ostream/op_ostream.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/ostream/basic_ostream/op_ostream.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ostream/basic_ostream/op_ostream.md b/reference/ostream/basic_ostream/op_ostream.md
index 953a63e23..b09323e4d 100644
--- a/reference/ostream/basic_ostream/op_ostream.md
+++ b/reference/ostream/basic_ostream/op_ostream.md
@@ -67,7 +67,7 @@ basic_ostream&amp;amp; operator&amp;lt;&amp;lt;(basic_streambuf&amp;lt;CharT, Traits&amp;gt;* sb); // (20) C++03
     - (16) 拡張浮動小数点数型:
         - 変換順位が`double`以下であれば、`static_cast&amp;lt;double&amp;gt;(f)`
         - そうでなく変換順位が`long double`以下であれば、`static_cast&amp;lt;long double&amp;gt;(f)`
-        - そうでなければ実装定義の意味論を持ち、この演算子は条件付きサポートとなる
+        - そうでなければ処理系定義の意味論を持ち、この演算子は条件付きサポートとなる
     - (18) `const volatile void*`:
         - `return operator&amp;lt;&amp;lt;(const_cast&amp;lt;const void*&amp;gt;(val));`
 1. `num_put::put`から得られた`iostate`値を実引数にして`setstate`関数を呼び出す
@@ -75,7 +75,7 @@ basic_ostream&amp;amp; operator&amp;lt;&amp;lt;(basic_streambuf&amp;lt;CharT, Traits&amp;gt;* sb); // (20) C++03
 
 ### (19) : `nullptr_t`の出力
 
-- C++17 : 実装定義の出力文字列`s`を、`return operator&amp;lt;&amp;lt;(s)`として渡した場合と等価である。
+- C++17 : 処理系定義の出力文字列`s`を、`return operator&amp;lt;&amp;lt;(s)`として渡した場合と等価である。
 
 
 ### (20) : ストリームバッファの非書式化出力
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>vprint_unicode -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/ostream/vprint_unicode.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/ostream/vprint_unicode.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/ostream/vprint_unicode.md b/reference/ostream/vprint_unicode.md
index c1b4a8618..f006d587c 100644
--- a/reference/ostream/vprint_unicode.md
+++ b/reference/ostream/vprint_unicode.md
@@ -33,7 +33,7 @@ namespace std {
     * string[link /reference/string/basic_string.md]
     * vformat[link /reference/format/vformat.md]
 
-- `os`が実装定義されたUnicodeを表示できる端末を参照するストリームである場合、ネイティブのUnicode APIを使用して端末に書き出す
+- `os`が処理系定義されたUnicodeを表示できる端末を参照するストリームである場合、ネイティブのUnicode APIを使用して端末に書き出す
 - `out`に無効なコードユニットが含まれる場合、その動作は未定義であり，実装者はそれを診断することが推奨される
 - ネイティブのUnicode APIを使用する場合、この関数は`out`を書き出す前にフラッシュする
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>linear_congruential_engine -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/random/linear_congruential_engine.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/random/linear_congruential_engine.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/random/linear_congruential_engine.md b/reference/random/linear_congruential_engine.md
index 1178d1078..106142738 100644
--- a/reference/random/linear_congruential_engine.md
+++ b/reference/random/linear_congruential_engine.md
@@ -35,7 +35,7 @@ $$x_{n+1}= (a \times x_n + c) \bmod m$$
 * 周期が短い(2&amp;lt;sup&amp;gt;31&amp;lt;/sup&amp;gt;-1)
 
 省メモリで高速という点から、多くの言語で、標準の乱数生成法として使用されている。  
-C言語から引き継いだ標準ライブラリ関数[`std::rand()`](/reference/cstdlib/rand.md)の乱数生成法は実装定義だが、多くの実装で線形合同法が使用されている。
+C言語から引き継いだ標準ライブラリ関数[`std::rand()`](/reference/cstdlib/rand.md)の乱数生成法は処理系定義だが、多くの実装で線形合同法が使用されている。
 
 
 しかし、メモリ使用量がそれほど問題にならないのであれば、メルセンヌ・ツイスター([`mt19937`](mt19937.md))の使用を検討した方がいいだろう。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>operator() -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/random/random_device/op_call.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/random/random_device/op_call.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/random/random_device/op_call.md b/reference/random/random_device/op_call.md
index 2b43dc2f1..67cb32933 100644
--- a/reference/random/random_device/op_call.md
+++ b/reference/random/random_device/op_call.md
@@ -14,12 +14,12 @@ result_type operator()();
 
 
 ## 戻り値
-実装定義な方法で、非決定論的な乱数を生成して返す。  
+処理系定義な方法で、非決定論的な乱数を生成して返す。  
 値の範囲は`[`[`min()`](min.md), [`max()`](max.md)`]`である。つまり、最小値と最大値両方を含む。
 
 
 ## 例外
-非決定論的な乱数を生成できなかった場合、[`exception`](/reference/exception/exception.md)から派生した実装定義の例外オブジェクトを送出する。
+非決定論的な乱数を生成できなかった場合、[`exception`](/reference/exception/exception.md)から派生した処理系定義の例外オブジェクトを送出する。
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンストラクタ -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/random/random_device/op_constructor.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/random/random_device/op_constructor.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/random/random_device/op_constructor.md b/reference/random/random_device/op_constructor.md
index f4efdfc36..0b618bafb 100644
--- a/reference/random/random_device/op_constructor.md
+++ b/reference/random/random_device/op_constructor.md
@@ -17,8 +17,8 @@ random_device(const random_device&amp;amp;) = delete;                         // (3)
 
 ## 概要
 - (1) : デフォルトコンストラクタ
-    - C++17まで : トークンを受け取って乱数生成器を構築する。デフォルトのトークンパラメータは実装定義である。
-    - C++20 : 実装定義のデフォルトトークンパラメータによって(2)に委譲。
+    - C++17まで : トークンを受け取って乱数生成器を構築する。デフォルトのトークンパラメータは処理系定義である。
+    - C++20 : 処理系定義のデフォルトトークンパラメータによって(2)に委譲。
 - (2) : トークンを受け取って乱数生成器を構築する。
     - ※実装は、このトークンパラメータによって、異なるランダムのソースを使用してもよい。
 - (3) : コピーコンストラクタ。コピー禁止。
@@ -37,7 +37,7 @@ random_device(const random_device&amp;amp;) = delete;                         // (3)
       デフォルトでは、CPU の `RDRAND` 命令が使用できれば (`_GLIBCXX_X86_RDRAND` が定義されていれば) それを、そうでなければ `/dev/urandom` から値を取得する
 
 ## 例外
-- (1), (2) : 乱数生成器を初期化できなかった場合、[`exception`](/reference/exception/exception.md)から派生した実装定義の例外オブジェクトを送出する
+- (1), (2) : 乱数生成器を初期化できなかった場合、[`exception`](/reference/exception/exception.md)から派生した処理系定義の例外オブジェクトを送出する
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>regex_constants -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/regex/regex_constants.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/regex/regex_constants.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <content type="html">&lt;div class=&#34;identifier-type&#34;&gt;namespace&lt;/div&gt;&lt;div class=&#34;header&#34;&gt;&amp;lt;regex&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;namespace&#34; title=&#34;namespace std&#34;&gt;std::&lt;/span&gt;&lt;span class=&#34;token&#34;&gt;regex_constants&lt;/span&gt;&lt;span class=&#34;cpp cpp11&#34; title=&#34;C++11で追加&#34;&gt;(C++11)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;std::regex_constants&lt;/code&gt;名前空間では、正規表現の構文オプション、マッチフラグ、エラー値などの定数を定義する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;regex_constants/syntax_option_type.html&#34;&gt;syntax_option_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;構文オプションを表す処理系定義のビットマスク型(type-alias)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;regex_constants/match_flag_type.html&#34;&gt;match_flag_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;マッチ条件と書式を表す処理系定義のビットマスク型(type-alias)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;regex_constants/error_type.html&#34;&gt;error_type&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正規表現のエラーを表す処理系定義の列挙型(enum)&lt;/td&gt;
&lt;td&gt;C++11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>error_type -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/regex/regex_constants/error_type.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/regex/regex_constants/error_type.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/regex/regex_constants/error_type.md b/reference/regex/regex_constants/error_type.md
index afd8b8545..a57eba736 100644
--- a/reference/regex/regex_constants/error_type.md
+++ b/reference/regex/regex_constants/error_type.md
@@ -43,7 +43,7 @@ namespace regex_constants {
 * unspecified[italic]
 
 ## 概要
-正規表現のエラーを表す実装定義の列挙型。
+正規表現のエラーを表す処理系定義の列挙型。
 
 
 | 名前 | 説明 | 対応バージョン |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>match_flag_type -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/regex/regex_constants/match_flag_type.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/regex/regex_constants/match_flag_type.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/regex/regex_constants/match_flag_type.md b/reference/regex/regex_constants/match_flag_type.md
index 1233090d4..fb1846583 100644
--- a/reference/regex/regex_constants/match_flag_type.md
+++ b/reference/regex/regex_constants/match_flag_type.md
@@ -43,7 +43,7 @@ namespace regex_constants{
 * unspecified[italic]
 
 ## 概要
-マッチ条件と書式を表す実装定義のビットマスク型
+マッチ条件と書式を表す処理系定義のビットマスク型
 
 
 | 名前 | 説明 | 対応バージョン |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>syntax_option_type -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/regex/regex_constants/syntax_option_type.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/regex/regex_constants/syntax_option_type.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/regex/regex_constants/syntax_option_type.md b/reference/regex/regex_constants/syntax_option_type.md
index fd3eaa840..82406b719 100644
--- a/reference/regex/regex_constants/syntax_option_type.md
+++ b/reference/regex/regex_constants/syntax_option_type.md
@@ -38,7 +38,7 @@ namespace regex_constants {
 * unspecified[italic]
 
 ## 概要
-構文オプションを表す実装定義のビットマスク型。
+構文オプションを表す処理系定義のビットマスク型。
 
 
 | 名前 | 説明 | 対応バージョン |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>regex_traits -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/regex/regex_traits.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/regex/regex_traits.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/regex/regex_traits.md b/reference/regex/regex_traits.md
index fba5f7edc..18082b500 100644
--- a/reference/regex/regex_traits.md
+++ b/reference/regex/regex_traits.md
@@ -58,7 +58,7 @@ namespace std {
 | `char_type`       | テンプレートパラメータ`CharT` | C++11 |
 | `string_type`     | `char_type`文字を要素とする文字列型 [`std::basic_string`](/reference/string/basic_string.md)`&amp;lt;char_type&amp;gt;` | C++11 |
 | `locale_type`     | ロケール型 [`std::locale`](/reference/locale/locale.md) | C++11 |
-| `char_class_type` | 正規表現の文字クラス名を表す、実装定義のビットマスク型 | C++11 |
+| `char_class_type` | 正規表現の文字クラス名を表す、処理系定義のビットマスク型 | C++11 |
 
 
 ## 例
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>set -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/set/set.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/set/set.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/set/set.md b/reference/set/set.md
index c1b6460fb..190b57876 100644
--- a/reference/set/set.md
+++ b/reference/set/set.md
@@ -130,7 +130,7 @@ namespace std {
 | `reverse_iterator` | 逆順双方向イテレータ。`std::`[`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;iterator&amp;gt;`。 | |
 | `const_reverse_iterator` | 読み取り専用逆順双方向イテレータ。`std::`[`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;const_iterator&amp;gt;`。 | |
 | `node_type`              | [`node_handle`](/reference/node_handle/node_handle.md)クラステンプレートの特殊化。 | C++17          |
-| `insert_return_type`     | ノードを挿入した結果を記述するために使用されるクラス型。以下に示す`insert-return-type`テンプレートの特殊化である。ただし、これは説明用のクラスであり、実装定義である。| C++17 |
+| `insert_return_type`     | ノードを挿入した結果を記述するために使用されるクラス型。以下に示す`insert-return-type`テンプレートの特殊化である。ただし、これは説明用のクラスであり、処理系定義である。| C++17 |
 
 ```cpp
 template &amp;lt;class Iterator, class NodeType&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>span -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/span/span.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/span/span.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/span/span.md b/reference/span/span.md
index f29a43993..dabfbd9f7 100644
--- a/reference/span/span.md
+++ b/reference/span/span.md
@@ -132,7 +132,7 @@ namespace std {
 | `const_pointer` | `const`ポインタ型 `const element_type*` | C++20 |
 | `reference` | 参照型 `element_type&amp;amp;` | C++20 |
 | `const_reference` | `const`参照型 `const element_type&amp;amp;` | C++20 |
-| `iterator` | 実装定義のイテレータ型。[`contiguous_iterator`](/reference/iterator/contiguous_iterator.md)、[`random_access_iterator`](/reference/iterator/random_access_iterator.md)、constexprイテレータのモデルであり、コンテナのイテレータに対するすべての要件を満たす | C++20 |
+| `iterator` | 処理系定義のイテレータ型。[`contiguous_iterator`](/reference/iterator/contiguous_iterator.md)、[`random_access_iterator`](/reference/iterator/random_access_iterator.md)、constexprイテレータのモデルであり、コンテナのイテレータに対するすべての要件を満たす | C++20 |
 | `reverse_iterator` | 逆順イテレータ [`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;iterator&amp;gt;` | C++20 |
 | `const_iterator` | 読み取り専用イテレータ [`std::const_iterator`](/reference/iterator/const_iterator.md)`&amp;lt;iterator&amp;gt;` | C++23 |
 | `const_reverse_iterator` | 読み取り専用逆イテレータ [`std::const_iterator`](/reference/iterator/const_iterator.md)`&amp;lt;reverse_iterator&amp;gt;` | C++23 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_stacktrace -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/stacktrace/basic_stacktrace.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/stacktrace/basic_stacktrace.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stacktrace/basic_stacktrace.md b/reference/stacktrace/basic_stacktrace.md
index fa1b3632a..4abc6f280 100644
--- a/reference/stacktrace/basic_stacktrace.md
+++ b/reference/stacktrace/basic_stacktrace.md
@@ -108,12 +108,12 @@ namespace std {
 | `value_type`       | 要素型 [`stacktrace_entry`](stacktrace_entry.md) | C++23 |
 | `const_reference`  | `const`参照型 `const value_type&amp;amp;` | C++23 |
 | `reference`        | 参照型 `value_type&amp;amp;` | C++23 |
-| `const_iterator`   | 読み取り専用イテレータ型。実装定義のランダムアクセスイテレータ | C++23 |
+| `const_iterator`   | 読み取り専用イテレータ型。処理系定義のランダムアクセスイテレータ | C++23 |
 | `iterator`         | イテレータ型 `const_iterator` | C++23 |
 | `reverse_iterator` | 逆順イテレータ型 [`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;iterator&amp;gt;` | C++23 |
 | `const_reverse_iterator` | 読み取り専用逆順イテレータ型 [`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;const_iterator&amp;gt;` | C++23 |
-| `diferrence_type`  | イテレータの差を表す型。実装定義 | C++23 |
-| `size_type`        | 要素数を表す型。実装定義 | C++23 |
+| `diferrence_type`  | イテレータの差を表す型。処理系定義 | C++23 |
+| `size_type`        | 要素数を表す型。処理系定義 | C++23 |
 | `allocator_type`   | アロケータ型 `allocator` | C++23 |
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>native_handle -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/stacktrace/stacktrace_entry/native_handle.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/stacktrace/stacktrace_entry/native_handle.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/stacktrace/stacktrace_entry/native_handle.md b/reference/stacktrace/stacktrace_entry/native_handle.md
index 996b6975d..604a47a3c 100644
--- a/reference/stacktrace/stacktrace_entry/native_handle.md
+++ b/reference/stacktrace/stacktrace_entry/native_handle.md
@@ -14,7 +14,7 @@ constexpr native_handle_type native_handle() const noexcept; // (1) C++23
 
 
 ## 戻り値
-実装定義のハンドルを返す。
+処理系定義のハンドルを返す。
 
 
 ## 備考
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>stdfloat -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/stdfloat.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/stdfloat.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <content type="html">&lt;div class=&#34;header&#34;&gt;&amp;lt;stdfloat&amp;gt;&lt;/div&gt;&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;stdfloat&lt;/span&gt;&lt;span class=&#34;cpp cpp23&#34; title=&#34;C++23で追加&#34;&gt;(C++23)&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;&amp;lt;stdfloat&amp;gt;&lt;/code&gt;ヘッダでは、処理系定義の拡張浮動小数点数型を定義する。&lt;/p&gt;
&lt;p&gt;これらの拡張浮動小数点数型は、ISO/IEC/IEEE 60559 (IEEE 754) 浮動小数点数規格に従った内部表現をもつことが規定される。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;対応バージョン&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;stdfloat/float16_t.html&#34;&gt;float16_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;16ビット半精度の浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;stdfloat/float32_t.html&#34;&gt;float32_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;32ビット単精度の浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;stdfloat/float64_t.html&#34;&gt;float64_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64ビット倍精度の浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;stdfloat/float128_t.html&#34;&gt;float128_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;128ビット四倍精度の浮動小数点数型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&lt;a href=&#34;stdfloat/bfloat16_t.html&#34;&gt;bfloat16_t&lt;/a&gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;16ビットのbrain floating point型&lt;/td&gt;
&lt;td&gt;C++23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;バージョン&lt;/h2&gt;
&lt;h3&gt;言語&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++23&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1467r9.html&#34; target=&#34;_blank&#34;&gt;P1467R9 Extended floating-point types and standard names&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>eof -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/string/char_traits/eof.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/string/char_traits/eof.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string/char_traits/eof.md b/reference/string/char_traits/eof.md
index 90b94bda3..d38e463df 100644
--- a/reference/string/char_traits/eof.md
+++ b/reference/string/char_traits/eof.md
@@ -19,9 +19,9 @@ static constexpr int_type eof() noexcept; // C++11
 標準で定義される特殊化は、以下の値を返す：
 
 - `char`： 定数値`EOF`を返す。
-- `char8_t`： UTF-8の文字単位として有効な、実装定義のEOFを表す定数値を返す。
-- `char16_t`： UTF-16の文字単位として有効な、実装定義のEOFを表す定数値を返す。
-- `char32_t`： Unicodeコードポイントとしての、実装定義のEOFを表す定数値を返す。
+- `char8_t`： UTF-8の文字単位として有効な、処理系定義のEOFを表す定数値を返す。
+- `char16_t`： UTF-16の文字単位として有効な、処理系定義のEOFを表す定数値を返す。
+- `char32_t`： Unicodeコードポイントとしての、処理系定義のEOFを表す定数値を返す。
 - `wchar_t`： 定数値`WEOF`を返す。
 
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>basic_string_view -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/string_view/basic_string_view.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/string_view/basic_string_view.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/string_view/basic_string_view.md b/reference/string_view/basic_string_view.md
index 96b45116c..5e2efdcf4 100644
--- a/reference/string_view/basic_string_view.md
+++ b/reference/string_view/basic_string_view.md
@@ -129,7 +129,7 @@ string_view hello = sv.substr(0, 5); // 先頭5文字を抽出する
 | `const_pointer` | `const`ポインタ型 `const value_type*` | C++17 |
 | `reference` | 参照型 `value_type&amp;amp;` | C++17 |
 | `const_reference` | `const`参照型 `const value_type&amp;amp;` | C++17 |
-| `const_iterator` | 読み取り専用イテレータ。実装定義。&amp;lt;br/&amp;gt; 要素の型は`value_type`。&amp;lt;br/&amp;gt; ランダムアクセスイテレータと連続イテレータの要件を満たす | C++17 |
+| `const_iterator` | 読み取り専用イテレータ。処理系定義。&amp;lt;br/&amp;gt; 要素の型は`value_type`。&amp;lt;br/&amp;gt; ランダムアクセスイテレータと連続イテレータの要件を満たす | C++17 |
 | `iterator` | イテレータ `const_iterator` | C++17 |
 | `const_reverse_iterator` | 読み取り専用逆イテレータ [`reverse_iterator`](/reference/iterator/reverse_iterator.md)`&amp;lt;const_iterator&amp;gt;` | C++17 |
 | `reverse_iterator` | 逆順イテレータ `const_reverse_iterator` | C++17 |
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>aligned_storage -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/type_traits/aligned_storage.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/type_traits/aligned_storage.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/type_traits/aligned_storage.md b/reference/type_traits/aligned_storage.md
index 0bebec2a6..b23b3a4c3 100644
--- a/reference/type_traits/aligned_storage.md
+++ b/reference/type_traits/aligned_storage.md
@@ -55,7 +55,7 @@ namespace std {
 - テンプレートパラメータとして型をとらず、サイズをとってしまっている
     - この機能は非常に稀な状況を除いて、`Align`パラメータは`Len`パラメータに対して決まった指定の仕方をする。第1テンプレート引数として`sizeof(T)`を指定するのであれば、第2テンプレート引数には`alignof(T)`を指定しなければならない。`typename aligned_storage&amp;lt;sizeof(T), alignof(T)&amp;gt;::type`
 - 第2テンプレートパラメータにデフォルト引数が設定されている
-    - このテンプレートパラメータは本来必要ないだけでなく、デフォルト引数が付けられてしまっている。コンパイラが`aligned_storage_t&amp;lt;sizeof(T)&amp;gt;`という使い方をやめさせる方法はない。第2テンプレートパラメータは実装定義のデフォルト値をもつが、`T`に対して十分な場合とそうでない場合がある。そのため、暗黙に不正確になることを許可してしまっている
+    - このテンプレートパラメータは本来必要ないだけでなく、デフォルト引数が付けられてしまっている。コンパイラが`aligned_storage_t&amp;lt;sizeof(T)&amp;gt;`という使い方をやめさせる方法はない。第2テンプレートパラメータは処理系定義のデフォルト値をもつが、`T`に対して十分な場合とそうでない場合がある。そのため、暗黙に不正確になることを許可してしまっている
 
 Facebookの`folly::aligned_storage_for_t`はこれらの問題を解決している。
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>type_info -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/typeinfo/type_info.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/typeinfo/type_info.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/typeinfo/type_info.md b/reference/typeinfo/type_info.md
index a7065706c..be67d4696 100644
--- a/reference/typeinfo/type_info.md
+++ b/reference/typeinfo/type_info.md
@@ -29,7 +29,7 @@ namespace std {
 | `operator=(const type_info&amp;amp;) = delete`      | 代入演算子                  | |
 | [`before`](type_info/before.md)           | 2つの型の照合順序を比較する | |
 | [`hash_code`](type_info/hash_code.md)     | 型のハッシュ値を取得する    | C++11 |
-| [`name`](type_info/name.md)               | 実装定義の型名を取得する    | |
+| [`name`](type_info/name.md)               | 処理系定義の型名を取得する    | |
 | [`operator==`](type_info/op_equal.md)     | 2つの型が同じかを判定する   | |
 | [`operator!=`](type_info/op_not_equal.md) | 2つの型が異なるかを判定する | |
 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>name -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/typeinfo/type_info/name.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/typeinfo/type_info/name.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/typeinfo/type_info/name.md b/reference/typeinfo/type_info/name.md
index 70936afbc..eb073d399 100644
--- a/reference/typeinfo/type_info/name.md
+++ b/reference/typeinfo/type_info/name.md
@@ -10,11 +10,11 @@ const char* name() const noexcept; // C++11
 ```
 
 ## 概要
-実装定義の型名を取得する
+処理系定義の型名を取得する
 
 
 ## 戻り値
-実装定義の型名を返す。
+処理系定義の型名を返す。
 
 
 ## 例外
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unordered_map -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/unordered_map/unordered_map.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/unordered_map/unordered_map.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_map/unordered_map.md b/reference/unordered_map/unordered_map.md
index cc119df6b..384054493 100644
--- a/reference/unordered_map/unordered_map.md
+++ b/reference/unordered_map/unordered_map.md
@@ -176,7 +176,7 @@ namespace std {
 | `local_iterator`       | 同一バケット内のみで有効なイテレータ。&amp;lt;br/&amp;gt;規格書には記載はないが、`iterator` と同様）`const_local_iterator` と同じ型か否かは実装依存であるものと思われる。&amp;lt;br/&amp;gt;`iterator` と、`iterator_category`、`value_type`、`difference_type`、`pointer`、`reference` は同一である。 | C++11 |
 | `const_local_iterator` | 同一バケット内のみで有効な読み取り専用イテレータ。&amp;lt;br/&amp;gt;`const_iterator` と、`iterator_category`、`value_type`、`difference_type`、`pointer`、`reference` は同一である。 | C++11 |
 | `node_type`            | [`node_handle`](/reference/node_handle/node_handle.md)クラステンプレートの特殊化。 | C++17 |
-| `insert_return_type`   | ノードを挿入した結果を記述するために使用されるクラス型。以下に示す`insert-return-type`テンプレートの特殊化である。ただし、これは説明用のクラスであり、実装定義である。| C++17 |
+| `insert_return_type`   | ノードを挿入した結果を記述するために使用されるクラス型。以下に示す`insert-return-type`テンプレートの特殊化である。ただし、これは説明用のクラスであり、処理系定義である。| C++17 |
 
 ```cpp
 template &amp;lt;class Iterator, class NodeType&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>unordered_set -- style: 表記統一 &#34;{実装 =&gt; 処理系}定義&#34;</title>
      <link href="https://cpprefjp.github.io/reference/unordered_set/unordered_set.html"/>
      <id>7fa228d0e6c12221c54846385d40492bf0569716:reference/unordered_set/unordered_set.md</id>
      <updated>2025-07-09T23:26:43+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/reference/unordered_set/unordered_set.md b/reference/unordered_set/unordered_set.md
index f66dc5714..588be037b 100644
--- a/reference/unordered_set/unordered_set.md
+++ b/reference/unordered_set/unordered_set.md
@@ -167,7 +167,7 @@ namespace std {
 | `local_iterator`       | 同一バケット内のみで有効なイテレータ。&amp;lt;br/&amp;gt;規格書に記載はないが、（`iterator` と同様）`const_local_iterator` と同じ型か否かは実装依存であるものと思われる。&amp;lt;br/&amp;gt;`iterator` と、`iterator_category`、`value_type`、`difference_type`、`pointer`、`reference` は同一である。 | C++11 |
 | `const_local_iterator` | 同一バケット内のみで有効な読み取り専用イテレータ。&amp;lt;br/&amp;gt;`const_iterator` と、`iterator_category`、`value_type`、`difference_type`、`pointer`、`reference` は同一である。 | C++11 |
 | `node_type`            | [`node_handle`](/reference/node_handle/node_handle.md)クラステンプレートの特殊化。 | C++17 |
-| `insert_return_type`   | ノードを挿入した結果を記述するために使用されるクラス型。以下に示す`insert-return-type`テンプレートの特殊化である。ただし、これは説明用のクラスであり、実装定義である。| C++17 |
+| `insert_return_type`   | ノードを挿入した結果を記述するために使用されるクラス型。以下に示す`insert-return-type`テンプレートの特殊化である。ただし、これは説明用のクラスであり、処理系定義である。| C++17 |
 
 ```cpp
 template &amp;lt;class Iterator, class NodeType&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Koichi Murase</name>
        <email>myoga.murase@gmail.com</email>
      </author>
    </entry>
  
</feed>